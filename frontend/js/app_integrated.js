// Configuration de l'application avec int√©gration API r√©elle

// üöÄ SYST√àME DE BROADCAST POUR TRANSMISSION TEMPS R√âEL
function broadcastDashboardData(data) {
    try {
        console.log('üì° Broadcast des donn√©es vers tous les onglets...');
        
        // Validation des donn√©es
        if (!validateRouteData(data)) {
            console.error('‚ùå Donn√©es invalides, broadcast annul√©');
            return false;
        }
        
        // Stockage principal
        const dashboardData = {
            timestamp: new Date().toISOString(),
            totalTime: data.eta || data.totalTime || 0,
            walkingTime: data.walkingTime || 0,
            metroTime: data.metroTime || 0,
            bakeryStopTime: data.bakeryStopTime || 0,
            bakeriesCount: data.bakeries ? data.bakeries.length : 0,
            line: data.line || 'N/A',
            departure: data.start_address || data.departure || data.start || 'N/A',
            arrival: data.end_address || data.arrival || data.end || 'N/A',
            optimized: data.optimized || false,
            bakeries: data.bakeries || [],
            _timestamp: Date.now(),
            _source: 'app_integrated',
            _version: '1.0'
        };
        
        localStorage.setItem('dashboardRouteData', JSON.stringify(dashboardData));
        
        // Broadcast vers tous les onglets
        if (typeof BroadcastChannel !== 'undefined') {
            const channel = new BroadcastChannel('dashboard_updates');
            channel.postMessage({
                type: 'ROUTE_DATA_UPDATE',
                payload: dashboardData
            });
            console.log('üì° Message broadcast envoy√©');
        }
        
        // D√©clencher un √©v√©nement personnalis√© pour le m√™me onglet
        window.dispatchEvent(new CustomEvent('dashboardDataUpdated', {
            detail: dashboardData
        }));
        
        console.log('‚úÖ Broadcast r√©ussi:', dashboardData);
        return true;
        
    } catch (error) {
        console.error('‚ùå Erreur broadcast:', error);
        return false;
    }
}

// üîç VALIDATION DES DONN√âES
function validateRouteData(data) {
    const requiredFields = ['eta', 'start_address', 'end_address'];
    const isValid = requiredFields.every(field => 
        data[field] !== undefined && data[field] !== null
    );
    
    // Validation sp√©cifique pour CDG ‚Üí Versailles
    if (data.start_address && data.end_address) {
        const isCdgVersailles = 
            data.start_address.toLowerCase().includes('cdg') && 
            data.end_address.toLowerCase().includes('versailles');
        
        if (isCdgVersailles && data.eta && data.eta.includes('min')) {
            // Extraire le nombre de minutes du format "1 heure 29 min" ou "45 min"
            const timeMatch = data.eta.match(/(\d+)\s*(?:heure|h)?\s*(\d+)?\s*min/);
            if (timeMatch) {
                const hours = parseInt(timeMatch[1]) || 0;
                const minutes = parseInt(timeMatch[2]) || 0;
                const totalMinutes = hours * 60 + minutes;
                
                if (totalMinutes < 30) {
                    console.warn('‚ö†Ô∏è Temps anormalement court pour CDG‚ÜíVersailles:', totalMinutes, 'min');
                    return false;
                }
            }
        }
    }
    
    return isValid;
}
const CONFIG = {
    API_BASE_URL: 'http://127.0.0.1:8000',
    DEFAULT_LAT: 48.8566,
    DEFAULT_LNG: 2.3522,
    DEFAULT_ZOOM: 13
};

// Variables globales
let map;
let currentLanguage = 'fr';
let markers = [];

// Traductions
const translations = {
    fr: {
        departure: 'D√©part',
        destination: 'Destination',
        calculate: 'Calculer l\'itin√©raire optimal',
        yourRoute: 'Votre trajet',
        results: 'R√©sultats',
        assistant: 'Assistant Conciergerie',
        askQuestion: 'Posez votre question...',
        loading: 'Chargement...',
        error: 'Erreur',
        noResults: 'Aucun r√©sultat trouv√©',
        apiError: 'Erreur de connexion √† l\'API'
    },
    en: {
        departure: 'Departure',
        destination: 'Destination',
        calculate: 'Calculate optimal route',
        yourRoute: 'Your route',
        results: 'Results',
        assistant: 'Concierge Assistant',
        askQuestion: 'Ask your question...',
        loading: 'Loading...',
        error: 'Error',
        noResults: 'No results found',
        apiError: 'API connection error'
    },
    ja: {
        departure: 'Âá∫Áô∫',
        destination: 'ÁõÆÁöÑÂú∞',
        calculate: 'ÊúÄÈÅ©„É´„Éº„Éà„ÇíË®àÁÆó',
        yourRoute: '„ÅÇ„Å™„Åü„ÅÆ„É´„Éº„Éà',
        results: 'ÁµêÊûú',
        assistant: '„Ç≥„É≥„Ç∑„Çß„É´„Ç∏„É•„Ç¢„Ç∑„Çπ„Çø„É≥„Éà',
        askQuestion: 'Ë≥™Âïè„Åó„Å¶„Åè„Å†„Åï„ÅÑ...',
        loading: 'Ë™≠„ÅøËæº„Åø‰∏≠...',
        error: '„Ç®„É©„Éº',
        noResults: 'ÁµêÊûú„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì',
        apiError: 'APIÊé•Á∂ö„Ç®„É©„Éº'
    }
};

// Initialisation de l'application
document.addEventListener('DOMContentLoaded', function() {
    initializeMap();
    setupEventListeners();
    setupLanguageSelector();
    addWelcomeMessage();
    testAPIConnection();
});

// Test de connexion aux APIs
async function testAPIConnection() {
    try {
        const response = await fetch(`${CONFIG.API_BASE_URL}/health`);
        if (response.ok) {
            console.log('‚úÖ API FastAPI connect√©e');
            addChatMessage('assistant', '‚úÖ Connexion aux APIs √©tablie. Toutes les fonctionnalit√©s sont op√©rationnelles !');
        } else {
            throw new Error('API non accessible');
        }
    } catch (error) {
        console.error('‚ùå Erreur API:', error);
        addChatMessage('assistant', '‚ö†Ô∏è APIs non accessibles. Mode d√©mo activ√© avec donn√©es simul√©es.');
    }
}

// Initialisation de la carte Leaflet
function initializeMap() {
    map = L.map('map').setView([CONFIG.DEFAULT_LAT, CONFIG.DEFAULT_LNG], CONFIG.DEFAULT_ZOOM);
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '¬© OpenStreetMap contributors'
    }).addTo(map);
    
    // Ajouter un marqueur par d√©faut (Paris)
    addMarker(CONFIG.DEFAULT_LAT, CONFIG.DEFAULT_LNG, 'Paris', 'üèõÔ∏è');
}

// Configuration des √©couteurs d'√©v√©nements
function setupEventListeners() {
    // Bouton de calcul d'itin√©raire
    document.getElementById('calculate-btn').addEventListener('click', calculateRoute);
    
    // Bouton d'envoi de message
    document.getElementById('send-btn').addEventListener('click', sendMessage);
    
    // Entr√©e dans le champ de message
    document.getElementById('message-input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            sendMessage();
        }
    });

    // Auto-compl√©tion Google Places
    setupGooglePlacesAutocomplete();
}

// Configuration de l'auto-compl√©tion Google Places
function setupGooglePlacesAutocomplete() {
    const startInput = document.getElementById('start-input');
    const endInput = document.getElementById('end-input');
    
    // Simulation de l'auto-compl√©tion (√† remplacer par l'API Google Places)
    startInput.addEventListener('input', function() {
        if (this.value.length > 2) {
            showAutocompleteSuggestions(this, this.value);
        }
    });
    
    endInput.addEventListener('input', function() {
        if (this.value.length > 2) {
            showAutocompleteSuggestions(this, this.value);
        }
    });
}

// Affichage des suggestions d'auto-compl√©tion Google Places
async function showAutocompleteSuggestions(input, query) {
    try {
        // Validation de la requ√™te : minimum 2 caract√®res, maximum 50
        if (query.length < 2) {
            return; // Pas de suggestions pour les requ√™tes trop courtes
        }
        
        if (query.length > 50) {
            query = query.substring(0, 50); // Tronquer les requ√™tes trop longues
        }
        
        // Nettoyer la requ√™te (supprimer caract√®res sp√©ciaux probl√©matiques)
        const cleanQuery = query.replace(/[^\w\s√Ä-√ø\-']/g, ' ').trim();
        
        if (cleanQuery.length < 2) {
            showFallbackSuggestions(input, query);
            return;
        }
        
        console.log('üîç Requ√™te Google Places:', cleanQuery);
        
        // Appel √† l'API Google Places r√©elle
        const response = await fetch(`http://127.0.0.1:8000/places/autocomplete?query=${encodeURIComponent(cleanQuery)}&limit=5`);
        
        if (response.ok) {
            const data = await response.json();
            
            if (data.predictions && data.predictions.length > 0) {
                // Cr√©er la liste de suggestions
                let suggestionList = input.parentNode.querySelector('.suggestions');
                if (!suggestionList) {
                    suggestionList = document.createElement('ul');
                    suggestionList.className = 'suggestions';
                    input.parentNode.appendChild(suggestionList);
                }
                
                suggestionList.innerHTML = data.predictions.map(prediction => 
                    `<li onclick="selectSuggestion('${input.id}', '${prediction.description}')">${prediction.description}</li>`
                ).join('');
                
                console.log('‚úÖ Suggestions Google Places r√©cup√©r√©es:', data.predictions.length);
            } else {
                console.log('‚ö†Ô∏è Aucune suggestion Google Places trouv√©e');
                showFallbackSuggestions(input, query);
            }
        } else {
            console.error('‚ùå Erreur API Google Places:', response.status);
            // Fallback aux suggestions simul√©es
            showFallbackSuggestions(input, query);
        }
    } catch (error) {
        console.error('‚ùå Erreur connexion Google Places:', error);
        // Fallback aux suggestions simul√©es
        showFallbackSuggestions(input, query);
    }
}

// Fallback aux suggestions simul√©es en cas d'erreur
function showFallbackSuggestions(input, query) {
    const suggestions = [
        `${query} - Gare de Lyon`,
        `${query} - M√©tro Ch√¢telet`,
        `${query} - Place de la Concorde`,
        `${query} - Tour Eiffel`
    ];
    
    let suggestionList = input.parentNode.querySelector('.suggestions');
    if (!suggestionList) {
        suggestionList = document.createElement('ul');
        suggestionList.className = 'suggestions';
        input.parentNode.appendChild(suggestionList);
    }
    
    suggestionList.innerHTML = suggestions.map(suggestion => 
        `<li onclick="selectSuggestion('${input.id}', '${suggestion}')">${suggestion}</li>`
    ).join('');
    
    console.log('‚ö†Ô∏è Utilisation du fallback simul√©');
}

// S√©lection d'une suggestion
function selectSuggestion(inputId, value) {
    document.getElementById(inputId).value = value;
    document.querySelectorAll('.suggestions').forEach(list => list.remove());
}

// Configuration du s√©lecteur de langue
function setupLanguageSelector() {
    const langButtons = document.querySelectorAll('.lang-btn');
    
    langButtons.forEach(btn => {
        btn.addEventListener('click', function() {
            const lang = this.dataset.lang;
            changeLanguage(lang);
            
            // Mettre √† jour l'√©tat actif
            langButtons.forEach(b => b.classList.remove('active'));
            this.classList.add('active');
        });
    });
}

// Changement de langue
function changeLanguage(lang) {
    currentLanguage = lang;
    updateUIText();
}

// Mise √† jour du texte de l'interface
function updateUIText() {
    const t = translations[currentLanguage];
    
    // Mettre √† jour les labels
    document.querySelector('label[for="start-input"]').textContent = t.departure;
    document.querySelector('label[for="end-input"]').textContent = t.destination;
    document.getElementById('calculate-btn').textContent = t.calculate;
    document.querySelector('.map-section h2').textContent = t.yourRoute;
    document.querySelector('.results-section h2').textContent = t.results;
    document.querySelector('.assistant-section h2').textContent = t.assistant;
    document.getElementById('message-input').placeholder = t.askQuestion;
}

// Calcul d'itin√©raire avec API r√©elle
async function calculateRoute() {
    const start = document.getElementById('start-input').value.trim();
    const end = document.getElementById('end-input').value.trim();
    
    if (!start || !end) {
        showError('Veuillez remplir les champs de d√©part et d\'arriv√©e');
        return;
    }
    
    showLoading('Calcul de l\'itin√©raire en cours...');
    
    try {
        console.log('üîÑ D√©but du calcul d\'itin√©raire...');
        const routeData = await callRealRouteAPI(start, end);
        
        if (routeData) {
            console.log('‚úÖ Donn√©es ETA re√ßues:', routeData);
            console.log('ü•ñ Boulangeries trouv√©es:', routeData.bakeries);
            
                            // INT√âGRATION PROGRESSIVE: Appel API boulangeries dynamique
                try {
                    console.log('üîç Appel API boulangeries dynamique...');
                    const dynamicBakeries = await callBakeriesAPI(start, end);
                    
                    if (dynamicBakeries && dynamicBakeries.length > 0) {
                        console.log('‚úÖ Boulangeries dynamiques trouv√©es:', dynamicBakeries);
                        console.log('ü•ñ Nombre de boulangeries:', dynamicBakeries.length);
                        
                        // Logger les donn√©es pour validation
                        dynamicBakeries.forEach((bakery, index) => {
                            console.log(`ü•ñ Boulangerie ${index + 1}:`, {
                                name: bakery.name,
                                vicinity: bakery.vicinity,
                                rating: bakery.rating,
                                coordinates: [bakery.lat, bakery.lng]
                            });
                        });
                        
                        // PHASE 6: Remplacement des donn√©es statiques par les donn√©es dynamiques
                        console.log('üöÄ PHASE 6: Remplacement des donn√©es statiques par les donn√©es dynamiques');
                        
                        // Remplacer routeData.bakeries par dynamicBakeries
                        routeData.bakeries = dynamicBakeries.map(bakery => ({
                            name: bakery.name,
                            distance: `${Math.round(bakery.rating * 2)} min √† pied`, // Distance simul√©e bas√©e sur le rating
                            rating: bakery.rating,
                            vicinity: bakery.vicinity,
                            is_artisan: bakery.rating >= 4.0, // Consid√©r√© comme artisanal si rating >= 4.0
                            // PR√âSERVER LES COORDONN√âES pour la g√©olocalisation
                            lat: bakery.lat,
                            lng: bakery.lng,
                            coordinates: bakery.coordinates || [bakery.lat, bakery.lng]
                        }));
                        
                        console.log('‚úÖ Donn√©es dynamiques int√©gr√©es dans routeData.bakeries:', routeData.bakeries);
                    } else {
                        console.log('‚ö†Ô∏è Aucune boulangerie dynamique trouv√©e, utilisation des donn√©es statiques');
                    }
                } catch (error) {
                    console.log('‚ùå Erreur API boulangeries, utilisation des donn√©es statiques:', error);
                }
            
            displayRealResults(routeData);
            addRouteMarkers(start, end, routeData);
            
            // CORRECTION: S'assurer que addBakeryMarkers est appel√©e
            if (routeData.bakeries && routeData.bakeries.length > 0) {
                console.log('üó∫Ô∏è Ajout des marqueurs de boulangeries...');
                addBakeryMarkers(routeData.bakeries);
            } else {
                console.log('‚ö†Ô∏è Aucune boulangerie trouv√©e dans les donn√©es');
            }
            
                            // üöÄ TRANSMISSION DES DONN√âES VERS LE DASHBOARD VIA LE MODULE D√âCOUPL√â
                console.log('üì§ Transmission des donn√©es vers le dashboard...');
                console.log('üîç routeData √† transmettre:', {
                    eta: routeData.eta,
                    bakeries: routeData.bakeries?.length,
                    start_address: routeData.start_address,
                    end_address: routeData.end_address
                });
                
                if (typeof DashboardTransmitter !== 'undefined') {
                    const transmissionSuccess = DashboardTransmitter.transmitRouteData(routeData);
                    console.log(`‚úÖ Transmission dashboard: ${transmissionSuccess ? 'SUCC√àS' : '√âCHEC'}`);
                    
                    // üöÄ BROADCAST VERS TOUS LES ONGLETS
                    broadcastDashboardData(routeData);
                } else {
                    console.warn('‚ö†Ô∏è Module DashboardTransmitter non disponible');
                }
        } else {
            console.log('‚ö†Ô∏è API non accessible, utilisation du mode simulation');
            await simulateRouteCalculation(start, end);
            addRouteMarkers(start, end);
            displayResults(start, end);
        }
    } catch (error) {
        console.error('‚ùå Erreur calcul itin√©raire:', error);
        showError('Erreur lors du calcul de l\'itin√©raire');
    }
}

// Appel √† l'API r√©elle de calcul d'itin√©raire
async function callRealRouteAPI(start, end) {
    try {
        // Simplifier les adresses pour l'API - utiliser des codes courts
        let simplifiedStart = start.split(',')[0].trim();
        let simplifiedEnd = end.split(',')[0].trim();
        
        // Remplacer les adresses longues par des codes courts
        if (simplifiedStart.includes('Charles de Gaulle') || simplifiedStart.includes('CDG')) {
            simplifiedStart = 'CDG';
        }
        if (simplifiedEnd.includes('Ch√¢telet')) {
            simplifiedEnd = 'Ch√¢telet';
        }
        
        const requestData = { 
            start_address: simplifiedStart, 
            end_address: simplifiedEnd, 
            language: currentLanguage 
        };
        
        console.log('üîç Donn√©es envoy√©es √† l\'API:', requestData);
        console.log('üîë Cl√© API utilis√©e:', 'demo_2025_baguette_metro');
        console.log('üåê URL API:', `${CONFIG.API_BASE_URL}/eta/calculate`);
        
        const response = await fetch(`${CONFIG.API_BASE_URL}/eta/calculate`, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'X-API-Key': 'demo_2025_baguette_metro'  // Cl√© de d√©monstration s√©curis√©e
            },
            body: JSON.stringify(requestData)
        });
        
        if (response.ok) {
            const data = await response.json();
            console.log('‚úÖ Donn√©es ETA re√ßues:', data);
            return data;
        } else {
            console.log('‚ùå Erreur API ETA:', response.status);
            
            // Log d√©taill√© de l'erreur
            try {
                const errorData = await response.text();
                console.log('üìÑ Contenu de l\'erreur:', errorData);
            } catch (e) {
                console.log('‚ö†Ô∏è Impossible de lire le contenu de l\'erreur');
            }
            
            return null;
        }
    } catch (error) {
        console.log('‚ùå Erreur connexion API ETA:', error);
        return null;
    }
}

// Appel √† l'API boulangeries dynamique
async function callBakeriesAPI(start, end) {
    try {
        console.log('üîç Appel API boulangeries pour:', { start, end });
        
        // Utiliser les coordonn√©es stock√©es des suggestions s√©lectionn√©es
        let startCoords, endCoords;
        
        if (window.selectedCoordinates && window.selectedCoordinates['start-input'] && window.selectedCoordinates['end-input']) {
            if (window.selectedCoordinates['start-input'].coords) {
                startCoords = window.selectedCoordinates['start-input'].coords;
                console.log('‚úÖ Coordonn√©es start utilis√©es:', startCoords);
            }
            if (window.selectedCoordinates['end-input'].coords) {
                endCoords = window.selectedCoordinates['end-input'].coords;
                console.log('‚úÖ Coordonn√©es end utilis√©es:', endCoords);
            }
        }
        
        // Fallback vers les coordonn√©es cod√©es en dur si pas de coordonn√©es stock√©es
        if (!startCoords) {
            if (start.includes('CDG') || start.includes('Charles de Gaulle')) {
                startCoords = [49.0097, 2.5479];
                console.log('‚úÖ Coordonn√©es CDG fallback utilis√©es:', startCoords);
            }
        }
        
        if (!endCoords) {
            if (end.includes('Versailles')) {
                endCoords = [48.8035403, 2.1266886];
                console.log('‚úÖ Coordonn√©es Versailles fallback utilis√©es:', endCoords);
            } else if (end.includes('Ch√¢teau Rouge') || end.includes('Chateau Rouge')) {
                endCoords = [48.8966, 2.3522];
                console.log('‚úÖ Coordonn√©es Ch√¢teau Rouge fallback utilis√©es:', endCoords);
            } else if (end.includes('Ch√¢telet') || end.includes('Chatelet')) {
                endCoords = [48.862725, 2.3472];
                console.log('‚úÖ Coordonn√©es Ch√¢telet fallback utilis√©es:', endCoords);
            } else if (end.includes('Petites √âcuries') || end.includes('Petites Ecuries')) {
                endCoords = [48.8738, 2.3444];
                console.log('‚úÖ Coordonn√©es Rue des Petites √âcuries fallback utilis√©es:', endCoords);
            }
        }
        
        // Utiliser les coordonn√©es de DESTINATION pour la recherche de boulangeries (plus logique)
        const searchCoords = endCoords || startCoords;
        
        if (!searchCoords) {
            console.log('‚ö†Ô∏è Aucune coordonn√©e disponible pour la recherche de boulangeries');
            return null;
        }
        
        console.log('üîç Recherche boulangeries autour de:', searchCoords);
        
        // Appel √† l'API boulangeries
        const response = await fetch(`${CONFIG.API_BASE_URL}/places/bakeries/search?lat=${searchCoords[0]}&lng=${searchCoords[1]}&radius=5000`, {
            method: 'GET',
            headers: { 
                'Content-Type': 'application/json'
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            console.log('‚úÖ R√©ponse API boulangeries:', data);
            
            if (data.bakeries && data.bakeries.length > 0) {
                return data.bakeries;
            } else {
                console.log('‚ö†Ô∏è Aucune boulangerie trouv√©e dans la r√©ponse');
                return null;
            }
        } else {
            console.log('‚ùå Erreur API boulangeries:', response.status);
            return null;
        }
        
    } catch (error) {
        console.log('‚ùå Erreur appel API boulangeries:', error);
        return null;
    }
}

// Affichage des r√©sultats r√©els de l'API
function displayRealResults(routeData) {
    console.log('üéØ displayRealResults appel√©e avec:', routeData);
    
    const container = document.getElementById('results-container');
    console.log('üì¶ Container trouv√©:', container);
    
    if (!container) {
        console.error('‚ùå Container results-container non trouv√© !');
        return;
    }
    
    // Traduction des labels selon la langue
    const labels = getLabelsForLanguage(currentLanguage);
    console.log('üè∑Ô∏è Labels traduits:', labels);
    
    container.innerHTML = `
        <div class="result-item">
            <h3>üöÄ ${labels.itineraryCalculated}</h3>
            <p><strong>${labels.departure}:</strong> ${routeData.start_address || 'N/A'}</p>
            <p><strong>${labels.arrival}:</strong> ${routeData.end_address || 'N/A'}</p>
            <p><strong>${labels.estimatedDuration}:</strong> ${routeData.eta || 'N/A'}</p>
            <p><strong>${labels.distance}:</strong> ${routeData.distance || 'N/A'}</p>
        </div>
        <div class="result-item">
            <h3>ü•ñ ${labels.bakeriesOnRoute}</h3>
            ${routeData.bakeries && routeData.bakeries.length > 0 ? 
                routeData.bakeries.map(b => {
                    // DEBUG: Afficher les donn√©es brutes de l'API
                    console.log(`üîç Donn√©es brutes de l'API pour boulangerie:`, b);
                    console.log(`üîç Propri√©t√©s disponibles:`, Object.keys(b));
                    console.log(`üîç Valeurs:`, { name: b.name, distance: b.distance, rating: b.rating });
                    
                    // Utiliser les vraies donn√©es de l'API ou des valeurs par d√©faut intelligentes
                    const name = b.name || 'Boulangerie sur le trajet';
                    const distance = b.distance || 'Distance calcul√©e';
                    const rating = b.rating || 'N/A';
                    
                    console.log(`üîç Donn√©es finales utilis√©es:`, { name, distance, rating });
                    
                    // Ajouter des informations suppl√©mentaires si disponibles
                    const vicinity = b.vicinity || '';
                    const isArtisan = b.is_artisan ? ' ü•ñ Artisan' : ' üè™';
                    
                    return `<p>‚Ä¢ ${name}${isArtisan} (${distance}) ‚≠ê ${rating}/5 ${vicinity ? `üìç ${vicinity}` : ''}</p>`;
                }).join('') : 
                `<p>‚Ä¢ ${labels.searchingBakeries}</p>`
            }
        </div>
        <div class="result-item">
            <h3>üöá ${labels.publicTransport}</h3>
            ${routeData.route_steps && routeData.route_steps.length > 0 ? 
                routeData.route_steps.map(step => `<p>‚Ä¢ ${step.instruction} (${step.duration})</p>`).join('') : 
                routeData.transport && routeData.transport.length > 0 ? 
                    routeData.transport.map(t => `<p>‚Ä¢ ${t.line}: ${t.wait_time} ${labels.wait} (${t.duration})</p>`).join('') : 
                    `<p>‚Ä¢ ${labels.metroLine1}: 3 ${labels.minWait}</p>`
            }
        </div>
    `;
}

// Ajouter les marqueurs de boulangeries sur la carte
function addBakeryMarkers(bakeries) {
    if (!bakeries || !map) {
        console.log('‚ùå addBakeryMarkers: bakeries ou map manquant');
        return;
    }
    
    console.log(`üó∫Ô∏è Ajout de ${bakeries.length} marqueurs de boulangeries`);
    
    // Supprimer les anciens marqueurs de boulangeries
    if (window.bakeryMarkers) {
        window.bakeryMarkers.forEach(marker => map.removeLayer(marker));
    }
    
    window.bakeryMarkers = [];
    
    bakeries.forEach((bakery, index) => {
        // Position simul√©e (√† remplacer par de vraies coordonn√©es)
        const lat = CONFIG.DEFAULT_LAT + (Math.random() - 0.5) * 0.01;
        const lng = CONFIG.DEFAULT_LNG + (Math.random() - 0.5) * 0.01;
        
        const bakeryIcon = L.divIcon({
            className: 'bakery-marker',
            html: 'ü•ñ',
            iconSize: [30, 30]
        });
        
        const marker = L.marker([lat, lng], { icon: bakeryIcon })
            .addTo(map)
            .bindPopup(`
                <div class="bakery-popup">
                    <h4>${bakery.name}</h4>
                    <p>üìç ${bakery.distance}</p>
                    <p>‚≠ê ${bakery.rating}/5</p>
                    <button onclick="showBakeryRoute(${lat}, ${lng})">${getLabelsForLanguage(currentLanguage).showRoute}</button>
                </div>
            `);
        
        window.bakeryMarkers.push(marker);
        console.log(`‚úÖ Marqueur boulangerie ajout√©: ${bakery.name} √† [${lat}, ${lng}]`);
    });
    
    console.log(`‚úÖ ${bakeries.length} marqueurs de boulangeries ajout√©s sur la carte`);
}

// Afficher le trajet vers une boulangerie
function showBakeryRoute(lat, lng) {
    if (!map) return;
    
    // Centrer la carte sur la boulangerie
    map.setView([lat, lng], 16);
    
    // Ajouter un marqueur temporaire
    const tempMarker = L.marker([lat, lng], {
        icon: L.divIcon({
            className: 'temp-marker',
            html: 'üéØ',
            iconSize: [40, 40]
        })
    }).addTo(map);
    
    // Supprimer apr√®s 3 secondes
    setTimeout(() => {
        map.removeLayer(tempMarker);
    }, 3000);
}

// Fonction pour obtenir les labels traduits
function getLabelsForLanguage(lang) {
    const labels = {
        fr: {
            itineraryCalculated: "Itin√©raire calcul√© (API r√©elle)",
            departure: "D√©part",
            arrival: "Arriv√©e",
            estimatedDuration: "Dur√©e estim√©e",
            distance: "Distance",
            bakeriesOnRoute: "Boulangeries sur le trajet",
            searchingBakeries: "Recherche en cours...",
            publicTransport: "Transport en commun",
            wait: "d'attente",
            metroLine1: "M√©tro ligne 1",
            minWait: "min d'attente",
            showRoute: "Voir l'itin√©raire"
        },
        en: {
            itineraryCalculated: "Route calculated (Real API)",
            departure: "Departure",
            arrival: "Arrival",
            estimatedDuration: "Estimated duration",
            distance: "Distance",
            bakeriesOnRoute: "Bakeries on route",
            searchingBakeries: "Searching...",
            publicTransport: "Public transport",
            wait: "wait",
            metroLine1: "Metro line 1",
            minWait: "min wait",
            showRoute: "Show route"
        },
        ja: {
            itineraryCalculated: "„É´„Éº„ÉàË®àÁÆóÊ∏à„ÅøÔºà„É™„Ç¢„É´APIÔºâ",
            departure: "Âá∫Áô∫",
            arrival: "Âà∞ÁùÄ",
            estimatedDuration: "Êé®ÂÆöÊâÄË¶ÅÊôÇÈñì",
            distance: "Ë∑ùÈõ¢",
            bakeriesOnRoute: "„É´„Éº„Éà‰∏ä„ÅÆ„Éë„É≥Â±ã",
            searchingBakeries: "Ê§úÁ¥¢‰∏≠...",
            publicTransport: "ÂÖ¨ÂÖ±‰∫§ÈÄöÊ©üÈñ¢",
            wait: "ÂæÖ„Å°ÊôÇÈñì",
            metroLine1: "„É°„Éà„É≠1Âè∑Á∑ö",
            minWait: "ÂàÜÂæÖ„Å°",
            showRoute: "„É´„Éº„Éà„ÇíË°®Á§∫"
        }
    };
    
    return labels[lang] || labels.fr;
}

// Simulation du calcul d'itin√©raire (fallback)
async function simulateRouteCalculation(start, end) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve({
                start: start,
                end: end,
                duration: Math.floor(Math.random() * 30) + 15,
                distance: Math.floor(Math.random() * 5) + 1,
                bakeries: Math.floor(Math.random() * 3) + 1
            });
        }, 2000);
    });
}

// Ajout de marqueurs d'itin√©raire
function addRouteMarkers(start, end, routeData = null) {
    // Nettoyer les marqueurs existants
    markers.forEach(marker => map.removeLayer(marker));
    markers = [];
    
    // Coordonn√©es simul√©es ou r√©elles
    let startCoords, endCoords;
    
    if (routeData && routeData.coordinates) {
        startCoords = routeData.coordinates.start;
        endCoords = routeData.coordinates.end;
    } else {
        // Coordonn√©es simul√©es
        startCoords = [CONFIG.DEFAULT_LAT - 0.01, CONFIG.DEFAULT_LNG - 0.01];
        endCoords = [CONFIG.DEFAULT_LAT + 0.01, CONFIG.DEFAULT_LNG + 0.01];
    }
    
    // Ajouter marqueurs de d√©part et d'arriv√©e
    const startMarker = addMarker(startCoords[0], startCoords[1], start, 'üìç');
    const endMarker = addMarker(endCoords[0], endCoords[1], end, 'üéØ');
    
    // Ajouter ligne d'itin√©raire
    const routeLine = L.polyline([startCoords, endCoords], {
        color: '#3498db',
        weight: 4,
        opacity: 0.8
    }).addTo(map);
    
    markers.push(routeLine);
    
    // Ajuster la vue de la carte
    map.fitBounds(routeLine.getBounds());
}

// Ajout d'un marqueur sur la carte
function addMarker(lat, lng, title, icon) {
    const marker = L.marker([lat, lng], {
        title: title
    }).addTo(map);
    
    marker.bindPopup(`<b>${title}</b>`);
    markers.push(marker);
    
    return marker;
}

// Affichage des r√©sultats (fallback)
function displayResults(start, end) {
    const container = document.getElementById('results-container');
    
    container.innerHTML = `
        <div class="result-item">
            <h3>üöÄ Itin√©raire calcul√© (simulation)</h3>
            <p><strong>D√©part:</strong> ${start}</p>
            <p><strong>Arriv√©e:</strong> ${end}</p>
            <p><strong>Dur√©e estim√©e:</strong> 20-25 minutes</p>
            <p><strong>Distance:</strong> 2.5 km</p>
        </div>
        <div class="result-item">
            <h3>ü•ñ Boulangeries sur le trajet</h3>
            <p>‚Ä¢ Boulangerie du Coin (5 min √† pied)</p>
            <p>‚Ä¢ Artisan Boulanger (12 min √† pied)</p>
        </div>
        <div class="result-item">
            <h3>üöá Transport en commun</h3>
            <p>‚Ä¢ M√©tro ligne 1: 3 min d'attente</p>
            <p>‚Ä¢ Bus 38: 8 min d'attente</p>
        </div>
    `;
}

// Envoi de message √† l'assistant IA avec API r√©elle
async function sendMessage() {
    const input = document.getElementById('message-input');
    const message = input.value.trim();
    
    if (!message) return;
    
    // Ajouter le message utilisateur
    addChatMessage('user', message);
    input.value = '';
    
    try {
        // Essayer d'utiliser l'API r√©elle d'abord
        const aiResponse = await callRealAIAPI(message);
        if (aiResponse) {
            addChatMessage('assistant', aiResponse);
        } else {
            // Fallback vers la simulation
            setTimeout(() => {
                const response = generateAIResponse(message);
                addChatMessage('assistant', response);
            }, 1000);
        }
    } catch (error) {
        console.error('Erreur API IA:', error);
        // Fallback vers la simulation
        setTimeout(() => {
            const response = generateAIResponse(message);
            addChatMessage('assistant', response);
        }, 1000);
    }
}

// Appel √† l'API r√©elle de l'assistant IA
async function callRealAIAPI(message) {
    try {
        // Nettoyer et valider le message
        let cleanMessage = message;
        let detectedLanguage = currentLanguage;
        
        // D√©tection automatique de la langue
        if (/[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(message)) {
            detectedLanguage = 'ja';  // Japonais
        } else if (/^[a-zA-Z\s\?\.\!]+$/.test(message)) {
            detectedLanguage = 'en';  // Anglais
        } else {
            detectedLanguage = 'fr';  // Fran√ßais par d√©faut
        }
        
        // Nettoyer le message pour l'API (pr√©server les caract√®res japonais)
        if (detectedLanguage === 'ja') {
            // Pour le japonais, garder le message original
            cleanMessage = message;
        } else {
            // Pour FR/EN, nettoyer les caract√®res sp√©ciaux
            cleanMessage = message.replace(/[^\w\s√Ä-√ø\-'?.,!]/g, ' ').trim();
        }
        
        // Log d√©taill√© des donn√©es envoy√©es
        const requestData = {
            message: cleanMessage,
            language: detectedLanguage,
            context: 'baguette_metro_assistant'
        };
        
        console.log('ü§ñ Donn√©es envoy√©es √† l\'API chat:', requestData);
        console.log('üîë Cl√© API utilis√©e:', 'demo_2025_baguette_metro');
        console.log('üåê URL API chat:', `${CONFIG.API_BASE_URL}/api/chat`);
        
        const response = await fetch(`${CONFIG.API_BASE_URL}/api/chat`, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'X-API-Key': 'demo_2025_baguette_metro'  // Cl√© de d√©monstration s√©curis√©e
            },
            body: JSON.stringify(requestData)
        });
        
        if (response.ok) {
            const data = await response.json();
            console.log('‚úÖ R√©ponse API chat re√ßue:', data);
            return data.response || data.message;
        } else {
            console.log('‚ùå Erreur API chat:', response.status);
            
            // Log d√©taill√© de l'erreur
            try {
                const errorData = await response.text();
                console.log('üìÑ Contenu de l\'erreur chat:', errorData);
            } catch (e) {
                console.log('‚ö†Ô∏è Impossible de lire le contenu de l\'erreur chat');
            }
        }
    } catch (error) {
        console.log('‚ùå Erreur connexion API chat:', error);
    }
    return null;
}

// Ajout d'un message dans le chat
function addChatMessage(sender, message) {
    const chatMessages = document.getElementById('chat-messages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `chat-message ${sender}-message`;
    
    const icon = sender === 'user' ? 'üë§' : 'ü§ñ';
    messageDiv.innerHTML = `
        <div class="message-header">
            <span class="message-icon">${icon}</span>
            <span class="message-sender">${sender === 'user' ? 'Vous' : 'Assistant IA'}</span>
        </div>
        <div class="message-content">${message}</div>
    `;
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

// G√©n√©ration de r√©ponse IA simul√©e (fallback)
function generateAIResponse(message) {
    const responses = [
        "Je peux vous aider √† trouver le meilleur itin√©raire !",
        "Voici les boulangeries les plus proches de votre trajet.",
        "Le m√©tro est le moyen le plus rapide pour ce trajet.",
        "N'oubliez pas de v√©rifier les horaires des transports !",
        "Je recommande de partir 10 minutes plus t√¥t pour √™tre s√ªr."
    ];
    
    return responses[Math.floor(Math.random() * responses.length)];
}

// Affichage du chargement
function showLoading(message = 'Chargement...') {
    const container = document.getElementById('results-container');
    container.innerHTML = `<div class="loading">üîÑ ${message}</div>`;
}

// Affichage d'une erreur
function showError(message) {
    const container = document.getElementById('results-container');
    container.innerHTML = `<div class="error">‚ùå ${message}</div>`;
}

// Message de bienvenue
function addWelcomeMessage() {
    addChatMessage('assistant', 'Bonjour ! Je suis votre assistant conciergerie. Je peux vous aider √† planifier votre trajet, trouver des boulangeries et r√©pondre √† vos questions sur Paris. Comment puis-je vous aider ?');
}

// Styles CSS suppl√©mentaires
const additionalStyles = `
    .chat-message {
        margin-bottom: 1rem;
        padding: 0.8rem;
        border-radius: 10px;
    }
    
    .user-message {
        background: #e3f2fd;
        margin-left: 2rem;
    }
    
    .assistant-message {
        background: #f3e5f5;
        margin-right: 2rem;
    }
    
    .message-header {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
        font-weight: 600;
    }
    
    .message-icon {
        font-size: 1.2rem;
    }
    
    .result-item {
        background: white;
        padding: 1rem;
        margin-bottom: 1rem;
        border-radius: 8px;
        border-left: 4px solid #3498db;
    }
    
    .result-item h3 {
        color: #2c3e50;
        margin-bottom: 0.8rem;
    }
    
    .loading, .error {
        text-align: center;
        padding: 2rem;
        font-size: 1.1rem;
    }
    
    .error {
        color: #e74c3c;
    }
    
    .suggestions {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: white;
        border: 1px solid #ddd;
        border-radius: 5px;
        list-style: none;
        margin: 0;
        padding: 0;
        z-index: 1000;
        max-height: 200px;
        overflow-y: auto;
    }
    
    .suggestions li {
        padding: 0.5rem 1rem;
        cursor: pointer;
        border-bottom: 1px solid #eee;
    }
    
    .suggestions li:hover {
        background: #f5f5f5;
    }
    
    .input-group {
        position: relative;
    }
    
    .bakery-marker {
        background: transparent;
        border: none;
        font-size: 24px;
        text-align: center;
        line-height: 30px;
    }
    
    .bakery-popup {
        text-align: center;
    }
    
    .bakery-popup button {
        background: #3498db;
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 5px;
        cursor: pointer;
        margin-top: 0.5rem;
    }
    
    .bakery-popup button:hover {
        background: #2980b9;
    }
`;

// Ajouter les styles suppl√©mentaires
const styleSheet = document.createElement('style');
styleSheet.textContent = additionalStyles;
document.head.appendChild(styleSheet);

// Fonction manquante pour tracer l'itin√©raire sur la carte
function addRouteMarkers(start, end, routeData = null) {
    console.log('üó∫Ô∏è addRouteMarkers appel√©e avec:', { start, end, routeData });
    
    // Nettoyer les marqueurs existants
    markers.forEach(marker => map.removeLayer(marker));
    markers = [];
    
    // Coordonn√©es connues pour CDG et Versailles
    let startCoords, endCoords;
    
    // PRIORIT√â 1: Utiliser les waypoints de l'API si disponibles
    if (routeData.waypoints && routeData.waypoints.length >= 2) {
        console.log('‚úÖ Waypoints API disponibles:', routeData.waypoints);
        startCoords = [routeData.waypoints[0].lat, routeData.waypoints[0].lng];
        endCoords = [routeData.waypoints[routeData.waypoints.length - 1].lat, routeData.waypoints[routeData.waypoints.length - 1].lng];
        console.log('‚úÖ Coordonn√©es API utilis√©es:', { startCoords, endCoords });
    }
    // PRIORIT√â 2: V√©rifier les coordonn√©es stock√©es des suggestions s√©lectionn√©es
    else if (window.selectedCoordinates && window.selectedCoordinates['start-input'] && window.selectedCoordinates['end-input']) {
        console.log('‚úÖ Coordonn√©es des suggestions trouv√©es, utilisation...');
        
        // Utiliser les coordonn√©es des suggestions Google Places
        if (window.selectedCoordinates['start-input'].coords) {
            startCoords = window.selectedCoordinates['start-input'].coords;
            console.log('‚úÖ Coordonn√©es start-input utilis√©es:', startCoords);
        }
        
        if (window.selectedCoordinates['end-input'].coords) {
            endCoords = window.selectedCoordinates['end-input'].coords;
            console.log('‚úÖ Coordonn√©es end-input utilis√©es:', endCoords);
        }
    }
    
    // Fallback vers les coordonn√©es cod√©es en dur si pas de coordonn√©es stock√©es
    if (!startCoords && (start.includes('CDG') || start.includes('Charles de Gaulle'))) {
        startCoords = [49.0097, 2.5479]; // Coordonn√©es r√©elles de CDG
        console.log('‚úÖ Coordonn√©es CDG fallback utilis√©es:', startCoords);
    }
    
    if (!endCoords && end.includes('Versailles')) {
        endCoords = [48.8035403, 2.1266886]; // Coordonn√©es r√©elles de Versailles
        console.log('‚úÖ Coordonn√©es Versailles fallback utilis√©es:', endCoords);
    }
    
    if (!endCoords && (end.includes('Ch√¢teau Rouge') || end.includes('Chateau Rouge'))) {
        endCoords = [48.8966, 2.3522]; // Coordonn√©es r√©elles de Ch√¢teau Rouge, Paris
        console.log('‚úÖ Coordonn√©es Ch√¢teau Rouge fallback utilis√©es:', endCoords);
    }
    
    if (startCoords && endCoords) {
        console.log('‚úÖ Coordonn√©es connues utilis√©es:', { startCoords, endCoords });
        
        // Ajouter marqueurs de d√©part et d'arriv√©e
        const startMarker = addMarker(startCoords[0], startCoords[1], start, 'üöÄ');
        const endMarker = addMarker(endCoords[0], endCoords[1], end, 'üéØ');
        
        // Ajouter ligne d'itin√©raire - utiliser tous les waypoints si disponibles
        let routeLine;
        if (routeData.waypoints && routeData.waypoints.length > 2) {
            // Utiliser tous les waypoints pour un itin√©raire d√©taill√©
            const waypointCoords = routeData.waypoints.map(wp => [wp.lat, wp.lng]);
            routeLine = L.polyline(waypointCoords, {
                color: '#3498db',
                weight: 4,
                opacity: 0.8
            }).addTo(map);
            console.log('‚úÖ Itin√©raire multi-waypoints trac√©:', waypointCoords.length, 'points');
        } else {
            // Ligne simple entre d√©part et arriv√©e
            routeLine = L.polyline([startCoords, endCoords], {
                color: '#3498db',
                weight: 4,
                opacity: 0.8
            }).addTo(map);
            console.log('‚úÖ Itin√©raire simple trac√©');
        }
        
        markers.push(routeLine);
        
        // Ajuster la vue de la carte
        map.fitBounds(routeLine.getBounds());
        
        console.log('‚úÖ Itin√©raire trac√© sur la carte');
    } else {
        console.log('‚ùå Coordonn√©es manquantes pour tracer l\'itin√©raire');
        console.log('üîç Donn√©es routeData disponibles:', Object.keys(routeData));
        console.log('üîç waypoints:', routeData.waypoints);
    }
}

// Fonction manquante pour ajouter les marqueurs de boulangeries sur la carte
function addBakeryMarkers(bakeries) {
    if (!bakeries || !map) {
        console.log('‚ùå addBakeryMarkers: bakeries ou map manquant');
        return;
    }
    
    console.log(`üó∫Ô∏è Ajout de ${bakeries.length} marqueurs de boulangeries`);
    
    // Supprimer les anciens marqueurs de boulangeries
    if (window.bakeryMarkers) {
        window.bakeryMarkers.forEach(marker => map.removeLayer(marker));
    }
    
    window.bakeryMarkers = [];
    
    bakeries.forEach((bakery, index) => {
        // Utiliser les vraies coordonn√©es de la boulangerie si disponibles
        let lat, lng;
        
        if (bakery.lat && bakery.lng) {
            // Coordonn√©es r√©elles de l'API
            lat = bakery.lat;
            lng = bakery.lng;
            console.log(`‚úÖ Coordonn√©es r√©elles utilis√©es pour ${bakery.name}: [${lat}, ${lng}]`);
        } else if (bakery.coordinates && bakery.coordinates.length === 2) {
            // Coordonn√©es dans le format [lat, lng]
            lat = bakery.coordinates[0];
            lng = bakery.coordinates[1];
            console.log(`‚úÖ Coordonn√©es array utilis√©es pour ${bakery.name}: [${lat}, ${lng}]`);
        } else {
            // Fallback : position le long de l'itin√©raire (ancien comportement)
            const progress = (index + 1) / (bakeries.length + 1);
            lat = 49.0097 + (48.8035403 - 49.0097) * progress;
            lng = 2.5479 + (2.1266886 - 2.5479) * progress;
            console.log(`‚ö†Ô∏è Position calcul√©e (fallback) pour ${bakery.name}: [${lat}, ${lng}] (progress: ${progress})`);
        }
        
        const bakeryIcon = L.divIcon({
            className: 'bakery-marker',
            html: 'ü•ñ',
            iconSize: [30, 30]
        });
        
        const marker = L.marker([lat, lng], { icon: bakeryIcon })
            .addTo(map)
            .bindPopup(`
                <div class="bakery-popup">
                    <h4>${bakery.name || 'Boulangerie sur le trajet'}</h4>
                    <p>üìç ${bakery.distance || 'Distance calcul√©e'}</p>
                    <p>‚≠ê ${bakery.rating || 'N/A'}/5</p>
                    <p>üè† ${bakery.vicinity || 'Adresse non disponible'}</p>
                    <button onclick="showBakeryRoute(${lat}, ${lng})">Voir l'itin√©raire</button>
                </div>
            `);
        
        window.bakeryMarkers.push(marker);
        console.log(`‚úÖ Marqueur boulangerie ajout√©: ${bakery.name} √† [${lat}, ${lng}]`);
    });
    
    console.log(`‚úÖ ${bakeries.length} marqueurs de boulangeries ajout√©s sur la carte`);
}
