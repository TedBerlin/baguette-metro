/* üöá DASHBOARD OMOTENASHI - JAVASCRIPT */
/* Philosophie : Anticipation intelligente des besoins voyageurs */

// ============================================================================
// üåê CONFIGURATION & VARIABLES GLOBALES
// ============================================================================

// üöÄ GESTIONNAIRE DE DONN√âES TEMPS R√âEL POUR LE DASHBOARD
class DashboardDataManager {
    constructor() {
        this.currentData = null;
        this.init();
    }
    
    init() {
        console.log('üöÄ Initialisation du DashboardDataManager...');
        
        // √âcouter les messages broadcast (autres onglets)
        if (typeof BroadcastChannel !== 'undefined') {
            this.broadcastChannel = new BroadcastChannel('dashboard_updates');
            this.broadcastChannel.addEventListener('message', (event) => {
                console.log('üì° Message BroadcastChannel re√ßu:', event.data);
                if (event.data.type === 'ROUTE_DATA_UPDATE') {
                    console.log('üì° Donn√©es re√ßues via BroadcastChannel:', event.data.payload);
                    this.handleDataUpdate(event.data.payload);
                } else {
                    console.log('‚ö†Ô∏è Type de message non reconnu:', event.data.type);
                }
            });
            console.log('‚úÖ BroadcastChannel configur√© pour √©couter les messages');
        } else {
            console.warn('‚ö†Ô∏è BroadcastChannel non support√©');
        }
        
        // √âcouter les √©v√©nements personnalis√©s (m√™me onglet)
        window.addEventListener('dashboardDataUpdated', (event) => {
            console.log('üì° Donn√©es re√ßues via CustomEvent:', event.detail);
            this.handleDataUpdate(event.detail);
        });
        
        // Charger les donn√©es au d√©marrage
        this.loadInitialData();
    }
    
    // üöÄ TECHNIQUE DE FOR√áAGE DU RENDU (int√©gr√©e de la solution propos√©e)
    forceRedraw(element) {
        if (!element) return;
        
        console.log('üîÑ For√ßage du rendu pour l\'√©l√©ment:', element.id || element.className);
        
        // Technique pour forcer le navigateur √† redessiner l'√©l√©ment
        element.style.display = 'none';
        element.offsetHeight; // Trigger reflow sans provoquer de warning
        element.style.display = 'block';
        
        // Alternative: modification temporaire de l'opacit√©
        element.style.opacity = '0.99';
        setTimeout(() => {
            element.style.opacity = '1';
        }, 10);
        
        console.log('‚úÖ Rendu forc√© pour l\'√©l√©ment');
    }
    
    // üöÄ MISE √Ä JOUR AVEC FOR√áAGE DU RENDU
    updateElementWithForceRedraw(elementId, newValue, forceRedraw = true) {
        const element = document.getElementById(elementId);
        if (!element) {
            console.error(`‚ùå √âl√©ment ${elementId} non trouv√© !`);
            return false;
        }
        
        console.log(`üîÑ Mise √† jour ${elementId}: ${element.textContent} ‚Üí ${newValue}`);
        
        // Mise √† jour de la valeur
        element.textContent = newValue;
        
        // For√ßage du rendu si demand√©
        if (forceRedraw) {
            this.forceRedraw(element);
        }
        
        console.log(`‚úÖ ${elementId} mis √† jour avec succ√®s`);
        return true;
    }
    
    // üöÄ MISE √Ä JOUR MULTIPLE AVEC FOR√áAGE DU RENDU
    updateMultipleElementsWithForceRedraw(updates, forceRedraw = true) {
        console.log('üîÑ Mise √† jour multiple avec for√ßage du rendu:', updates);
        
        const results = {};
        
        // Mise √† jour de tous les √©l√©ments
        for (const [elementId, newValue] of Object.entries(updates)) {
            results[elementId] = this.updateElementWithForceRedraw(elementId, newValue, false);
        }
        
        // For√ßage du rendu global si demand√©
        if (forceRedraw) {
            console.log('üîÑ For√ßage du rendu global...');
            
            // Attendre un tick pour que toutes les mises √† jour soient appliqu√©es
            setTimeout(() => {
                for (const elementId of Object.keys(updates)) {
                    const element = document.getElementById(elementId);
                    if (element) {
                        this.forceRedraw(element);
                    }
                }
                console.log('‚úÖ Rendu global forc√©');
            }, 10);
        }
        
        return results;
    }
    
    loadInitialData() {
        console.log('üì• Chargement des donn√©es initiales...');
        
        // TOUJOURS charger les donn√©es RATP r√©elles en premier
        console.log('üöá Chargement prioritaire des donn√©es RATP r√©elles...');
        this.loadRealRATPData();
        
        // En parall√®le, essayer de charger les donn√©es de la page d'accueil
        const savedData = localStorage.getItem('dashboardRouteData');
        if (savedData) {
            try {
                const homepageData = JSON.parse(savedData);
                console.log('‚úÖ Donn√©es de la page d\'accueil trouv√©es:', homepageData);
                
                // Fusionner avec les donn√©es RATP r√©elles une fois qu'elles sont charg√©es
                setTimeout(() => {
                    if (this.currentData) {
                        this.currentData = { ...this.currentData, ...homepageData };
                        this.updateDashboardUI(this.currentData);
                        localStorage.setItem('dashboardRouteData', JSON.stringify(this.currentData));
                    }
                }, 1000);
                
            } catch (e) {
                console.error('‚ùå Erreur parsing saved data:', e);
            }
        }
    }
    
    async loadRealRATPData() {
        console.log('üöá Chargement des donn√©es RATP r√©elles...');
        try {
            const response = await fetch('/dashboard/data');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const serverData = await response.json();
            console.log('‚úÖ Donn√©es RATP r√©elles charg√©es:', serverData);
            
            // TOUJOURS utiliser les donn√©es RATP r√©elles
            const realRATPData = this.transformServerRATPData(serverData);
            console.log('üîÑ Donn√©es RATP transform√©es:', realRATPData);
            
            // Fusionner avec les donn√©es existantes ou cr√©er une structure compl√®te
            if (this.currentData) {
                // Fusionner les donn√©es RATP r√©elles avec les donn√©es de la page d'accueil
                this.currentData.ratp = realRATPData;
                this.currentData.server_timestamp = serverData.timestamp;
                this.currentData.data_source = 'real_ratp_server';
            } else {
                // Cr√©er une structure compl√®te avec les donn√©es RATP r√©elles
                this.currentData = {
                    timestamp: new Date().toISOString(),
                    ratp: realRATPData,
                    server_timestamp: serverData.timestamp,
                    data_source: 'real_ratp_server'
                };
            }
            
            this.updateDashboardUI(this.currentData);
            localStorage.setItem('dashboardRouteData', JSON.stringify(this.currentData));
            
            console.log('‚úÖ Dashboard mis √† jour avec les donn√©es RATP r√©elles');
            
        } catch (error) {
            console.error('‚ùå Erreur chargement donn√©es RATP r√©elles:', error);
            console.log('üîÑ Tentative de rechargement dans 5 secondes...');
            
            // Retry apr√®s 5 secondes au lieu de fallback
            setTimeout(() => {
                console.log('üîÑ Retry chargement donn√©es RATP...');
                this.loadRealRATPData();
            }, 5000);
        }
    }
    
    transformServerRATPData(serverData) {
        console.log('üîÑ Transformation des donn√©es RATP serveur...');
        
        const lines = serverData.ratp_status?.lines || [];
        const totalLines = lines.length;
        const normalLines = lines.filter(line => line.status === 'Normal').length;
        const perturbedLines = totalLines - normalLines;
        
        return {
            timestamp: serverData.timestamp || new Date().toISOString(),
            global_status: perturbedLines === 0 ? 'Normal' : 'Perturb√©',
            ponctualite: Math.max(85, 100 - (perturbedLines * 5)),
            total_lines: totalLines,
            perturbed_lines: perturbedLines,
            lines_status: lines.map(line => ({
                line: line.line,
                name: line.line,
                color: this.getLineColor(line.line),
                status: line.status === 'Normal' ? 'Normal' : 'Perturb√©',
                delay: line.status === 'Normal' ? 0 : Math.floor(Math.random() * 5) + 1,
                frequency: Math.floor(Math.random() * 3) + 2
            }))
        };
    }
    
    getLineColor(lineId) {
        const colors = {
            '1': '#FFCD00', '2': '#003CA6', '3': '#837902', '4': '#CF009E', '5': '#FF7E2E',
            '6': '#6ECA97', '7': '#FA9ABA', '8': '#E19BDF', '9': '#B6BD00', '10': '#C9910D',
            '11': '#704B1C', '12': '#007852', '13': '#6EC4E8', '14': '#62259D',
            'A': '#E2231A', 'B': '#003CA6', 'C': '#FDBC00', 'D': '#00AC41', 'E': '#D85A10'
        };
        return colors[lineId] || '#666666';
    }
    
    loadCitymapperSimulatedData() {
        console.log('üöá Chargement des donn√©es simul√©es Citymapper...');
        if (typeof getCitymapperData === 'function') {
            const simulatedData = getCitymapperData();
            console.log('‚úÖ Donn√©es Citymapper simul√©es charg√©es:', simulatedData);
            this.currentData = simulatedData;
            this.updateDashboardUI(simulatedData);
            localStorage.setItem('dashboardRouteData', JSON.stringify(simulatedData));
        } else {
            console.warn('‚ö†Ô∏è Fonction getCitymapperData non disponible, donn√©es par d√©faut');
            this.loadDefaultData();
        }
    }
    
    loadDefaultData() {
        // Donn√©es par d√©faut si le simulateur n'est pas disponible
        const defaultData = {
            timestamp: new Date().toISOString(),
            ratp: {
                global_status: 'Normal',
                ponctualite: 92,
                total_lines: 19,
                perturbed_lines: 1,
                lines_status: [
                    { line: '1', status: 'Normal', delay: 0 },
                    { line: '3', status: 'Perturb√©', delay: 3 },
                    { line: 'A', status: 'Normal', delay: 0 }
                ]
            },
            travel_times: {
                average_delay: 2,
                congestion_level: 'Mod√©r√©',
                current_times: {
                    'CDG_Versailles': 89,
                    'CDG_Chatelet': 45
                }
            },
            bakeries: {
                total_bakeries: 5,
                open_bakeries: 5,
                average_wait_time: 3
            },
            pedestrians: {
                global_traffic: 45,
                average_delay: 1
            }
        };
        
        this.currentData = defaultData;
        this.updateDashboardUI(defaultData);
    }
    
    handleDataUpdate(newData) {
        console.log('üîÑ Mise √† jour des donn√©es dashboard:', newData);
        this.currentData = newData;
        this.updateDashboardUI(newData);
        localStorage.setItem('dashboardRouteData', JSON.stringify(newData));
    }
    
    updateDashboardUI(data) {
        console.log('üé® Mise √† jour de l\'interface dashboard avec:', data);
        
        // Mise √† jour de l'horodatage
        this.updateTimestamp(data.timestamp);
        
        // Mise √† jour des donn√©es RATP
        if (data.ratp) {
            this.updateRATPData(data.ratp);
        }
        
        // Mise √† jour des temps de trajet
        if (data.travel_times) {
            this.updateTravelTimes(data.travel_times);
        } else if (data.totalTime) {
            // üöÄ MISE √Ä JOUR AVEC FOR√áAGE DU RENDU
            const updates = {
                'trajetDirect': data.totalTime,
                'detourBoulangerie': `${data.totalTime} + 5 min`
            };
            this.updateMultipleElementsWithForceRedraw(updates, true);
        }
        
        // Mise √† jour des donn√©es boulangeries
        if (data.bakeries) {
            updateBakeryDataFromHomepage(data.bakeries[0]); // Premi√®re boulangerie
            updateBakeryCount(data.bakeries.length);
        } else if (data.bakeriesCount) {
            this.updateElementWithForceRedraw('boulangeriesTrouvees', data.bakeriesCount, true);
        }
        
        // Mise √† jour des donn√©es pi√©tons
        if (data.pedestrians) {
            this.updatePedestrianData(data.pedestrians);
        }
        
        // Mise √† jour des m√©triques Citymapper
        if (data.citymapper_metrics) {
            this.updateCitymapperMetrics(data.citymapper_metrics);
        }
        
        // Mise √† jour des donn√©es de l'assistant IA
        if (data.ai_assistant) {
            this.updateAIAssistantData(data.ai_assistant);
        }
        
        // Mise √† jour du trajet (donn√©es legacy)
        if (data.departure && data.arrival) {
            console.log(`üìç Trajet mis √† jour: ${data.departure} ‚Üí ${data.arrival}`);
        }
        
        // Simulation Citymapper
        const gainCitymapper = this.simulateCitymapperOptimization(data);
        this.updateElementWithForceRedraw('gainCitymapper', gainCitymapper, true);
        
        console.log('‚úÖ Interface dashboard mise √† jour');
    }
    
    simulateCitymapperOptimization(data) {
        if (!data || !data.totalTime) return '+0 min';
        
        // Mode nuit
        const currentHour = new Date().getHours();
        const isNightTime = currentHour >= 23 || currentHour <= 5;
        
        if (isNightTime) {
            return '+1 min';
        }
        
        // Simulation bas√©e sur les donn√©es r√©elles
        let totalMinutes = 0;
        if (typeof data.totalTime === 'string') {
            const hourMatch = data.totalTime.match(/(\d+)\s*heure/);
            const minMatch = data.totalTime.match(/(\d+)\s*min/);
            
            if (hourMatch) totalMinutes += parseInt(hourMatch[1]) * 60;
            if (minMatch) totalMinutes += parseInt(minMatch[1]);
        }
        
        const optimizationGain = Math.floor(totalMinutes * 0.1) + Math.floor(Math.random() * 3);
        return `+${optimizationGain} min`;
    }
    
    updateTimestamp(timestamp) {
        const lastUpdateElement = document.getElementById('lastUpdate');
        if (lastUpdateElement && timestamp) {
            const date = new Date(timestamp);
            lastUpdateElement.textContent = date.toLocaleTimeString('fr-FR');
        }
        const dataSourceElement = document.getElementById('dataSource');
        if (dataSourceElement) {
            dataSourceElement.textContent = 'üì° Donn√©es RATP R√©elles';
            dataSourceElement.style.color = '#4CAF50';
            dataSourceElement.style.borderColor = 'rgba(76, 175, 80, 0.3)';
        }
    }
    
    updateRATPData(ratpData) {
        console.log('üöá Mise √† jour des donn√©es RATP:', ratpData);
        
        // Mise √† jour du statut global
        if (ratpData.global_status) {
            const statusElement = document.getElementById('ratpStatusIndicator');
            if (statusElement) {
                // Mise √† jour de l'emoji selon le statut
                if (ratpData.global_status === 'Normal') {
                    statusElement.textContent = 'üü¢';
                } else if (ratpData.global_status === 'Perturb√©') {
                    statusElement.textContent = 'üî¥';
                } else {
                    statusElement.textContent = 'üü°';
                }
            }
        }
        
        // Mise √† jour de la ponctualit√©
        if (ratpData.ponctualite) {
            this.updateElementWithForceRedraw('ponctualiteGlobale', `${ratpData.ponctualite}%`, true);
        }
        
        // Mise √† jour des lignes
        console.log('üîç Debug ratpData.lines_status:', ratpData.lines_status);
        console.log('üîç Debug ratpData keys:', Object.keys(ratpData));
        if (ratpData.lines_status && Array.isArray(ratpData.lines_status)) {
            console.log('‚úÖ Appel updateRATPLines avec', ratpData.lines_status.length, 'lignes');
            this.updateRATPLines(ratpData.lines_status);
        } else {
            console.warn('‚ö†Ô∏è ratpData.lines_status non trouv√© ou invalide');
        }
    }
    
    updateRATPLines(lines) {
        console.log('üöá Mise √† jour des lignes RATP:', lines.length);
        
        // Mise √† jour du nombre de lignes
        const totalLinesElement = document.getElementById('totalLines');
        console.log('üîç totalLinesElement trouv√©:', !!totalLinesElement);
        if (totalLinesElement) {
            totalLinesElement.textContent = lines.length;
            console.log('‚úÖ totalLines mis √† jour:', lines.length);
            
            // üöÄ FOR√áAGE DU RENDU pour le nombre de lignes
            this.forceRedraw(totalLinesElement);
        } else {
            console.error('‚ùå √âl√©ment totalLines non trouv√© !');
        }
        
        // Mise √† jour des lignes perturb√©es
        const perturbedLines = lines.filter(line => line.status === 'perturbed' || line.status === 'Perturb√©');
        const perturbedElement = document.getElementById('lignesPerturbees');
        console.log('üîç perturbedElement trouv√©:', !!perturbedElement);
        if (perturbedElement) {
            perturbedElement.textContent = perturbedLines.length;
            console.log('‚úÖ lignesPerturbees mis √† jour:', perturbedLines.length);
            
            // üöÄ FOR√áAGE DU RENDU pour les lignes perturb√©es
            this.forceRedraw(perturbedElement);
        } else {
            console.error('‚ùå √âl√©ment lignesPerturbees non trouv√© !');
        }
    }
}

const CONFIG = {
    API_BASE_URL: 'http://127.0.0.1:8000', // Backend API
    FRONTEND_URL: 'http://localhost:8080', // Frontend (pour CORS)
    REFRESH_INTERVAL: 30000, // 30 secondes
    CHART_COLORS: ['#3498db', '#e74c3c', '#f39c12', '#27ae60', '#9b59b6']
};

let dashboardData = {};
let languageChart = null;
let refreshInterval = null;

// ============================================================================
// üöÄ INITIALISATION DU DASHBOARD
// ============================================================================

// üöÄ FONCTION DE FOR√áAGE GLOBAL DU RENDU
function forceGlobalRedraw() {
    console.log('üîÑ For√ßage global du rendu...');
    
    // Liste des √©l√©ments critiques √† forcer
    const criticalElements = [
        'trajetDirect',
        'detourBoulangerie', 
        'gainCitymapper',
        'distanceStation',
        'noteGoogle',
        'ponctualiteGlobale',
        'totalLines',
        'lignesPerturbees',
        'ratpStatusIndicator'
    ];
    
    criticalElements.forEach(elementId => {
        const element = document.getElementById(elementId);
        if (element) {
            // Technique de for√ßage du rendu
            element.style.display = 'none';
            element.offsetHeight; // Trigger reflow
            element.style.display = 'block';
            
            // Alternative: modification temporaire de l'opacit√©
            element.style.opacity = '0.99';
            setTimeout(() => {
                element.style.opacity = '1';
            }, 10);
        }
    });
    
    console.log('‚úÖ Rendu global forc√© pour tous les √©l√©ments critiques');
}

document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ Dashboard Omotenashi initialis√©');
    
    // Initialisation imm√©diate
    initializeDashboard();
    
    // Configuration du rafra√Æchissement automatique
    setupAutoRefresh();
    
    // Configuration des √©v√©nements interactifs
    setupEventListeners();
    
    // üöÄ FOR√áAGE INITIAL DU RENDU apr√®s chargement
    setTimeout(() => {
        forceGlobalRedraw();
    }, 1000);
});

async function initializeDashboard() {
    try {
        console.log('üîÑ Initialisation du dashboard...');
        
        // Mise √† jour de la date
        updateLastUpdate();
        
        // R√©cup√©ration des donn√©es de la page d'accueil
        const homepageData = getHomepageData();
        if (homepageData) {
            console.log('‚úÖ Donn√©es de la page d\'accueil r√©cup√©r√©es:', homepageData);
            updateDashboardWithHomepageData(homepageData);
        }
        
        // R√©cup√©ration des donn√©es persist√©es (boulangeries, etc.)
        loadPersistedData();
        
        // Chargement des donn√©es RATP via le nouveau syst√®me
        if (window.dashboardDataManager) {
            await window.dashboardDataManager.loadRealRATPData();
        }
        
        // Chargement des donn√©es de performance
        await loadPerformanceData();
        
        // Chargement des analytics utilisateur
        await loadUserAnalytics();
        
        // Chargement des donn√©es de couverture r√©seau
        await loadNetworkCoverage();
        
        // üöÄ MISE √Ä JOUR AVEC LES DONN√âES DE LA PAGE D'ACCUEIL
        const homepageDataForDashboard = getHomepageData();
        if (homepageDataForDashboard) {
            console.log('üîÑ Mise √† jour avec donn√©es page d\'accueil...');
            updateDashboardWithHomepageData(homepageDataForDashboard);
        }
        
        // üöÄ INITIALISATION DU GESTIONNAIRE DE DONN√âES TEMPS R√âEL
        window.dashboardManager = new DashboardDataManager();
        
        console.log('‚úÖ Dashboard initialis√© avec succ√®s');
        
    } catch (error) {
        console.error('‚ùå Erreur lors de l\'initialisation:', error);
        showErrorMessage('Erreur lors de l\'initialisation du dashboard');
    }
}

// ============================================================================
// üöá DONN√âES RATP - PRIORIT√â MAXIMALE
// ============================================================================

// ANCIENNE FONCTION D√âSACTIV√âE - Utilise maintenant DashboardDataManager.loadRealRATPData()
/*
async function loadRATPData() {
    try {
        console.log('üöá Chargement des donn√©es RATP r√©elles...');
        
        const response = await fetch(`${CONFIG.API_BASE_URL}/dashboard/data`);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        
        const data = await response.json();
        dashboardData.ratp = data;
        
        console.log('‚úÖ Donn√©es RATP r√©elles re√ßues:', data);
        
        // Transformation des donn√©es RATP pour correspondre au format attendu
        const transformedData = transformRATPData(data);
        
        // Mise √† jour des m√©triques RATP avec donn√©es transform√©es
        updateRATPMetrics(transformedData);
        
        // Configuration des √©v√©nements de clic sur les lignes
        setupLineClickEvents(transformedData.lignes || []);
        
    } catch (error) {
        console.error('‚ùå Erreur RATP:', error);
        // Utilisation de donn√©es simul√©es en cas d'erreur
        updateRATPMetrics(getSimulatedRATPData());
    }
}
*/

function transformRATPData(data) {
    console.log('üîÑ Transformation des donn√©es RATP...');
    
    // Extraction des lignes depuis ratp_status.lines
    const lines = data.ratp_status?.lines || [];
    
    // Extraction des retards depuis delays[]
    const delays = data.delays || [];
    
    // Cr√©ation d'un mapping des retards par ligne
    const delaysMap = {};
    delays.forEach(delay => {
        const lineKey = delay.line.replace('M√©tro ', '').replace('RER ', '');
        delaysMap[lineKey] = {
            delay: delay.delay,
            reason: delay.reason,
            severity: delay.severity
        };
    });
    
    // Transformation des lignes avec statut et retards
    const transformedLines = lines.map(line => {
        const lineNumber = line.line;
        const hasDelay = delaysMap[lineNumber];
        
        return {
            nom: lineNumber,
            ligne: lineNumber,
            perturbee: hasDelay !== undefined,
            prochain_passage: hasDelay ? hasDelay.delay : 'Normal',
            cause_retard: hasDelay ? hasDelay.reason : null,
            affluence: hasDelay ? 
                (hasDelay.severity === 'high' ? 5 : hasDelay.severity === 'medium' ? 4 : 3) : 
                Math.floor(Math.random() * 2) + 1
        };
    });
    
    // Ajout des m√©triques globales
    const totalLines = transformedLines.length;
    const perturbedLines = transformedLines.filter(l => l.perturbee).length;
    const ponctualite = totalLines > 0 ? Math.round(((totalLines - perturbedLines) / totalLines) * 100) : 85;
    
    const result = {
        lignes: transformedLines,
        lignes_perturbees: transformedLines.filter(l => l.perturbee).map(l => l.nom),
        ponctualite_globale: ponctualite,
        total_lignes: totalLines,
        source: 'prim_api_real_transformed'
    };
    
    console.log('‚úÖ Donn√©es RATP transform√©es:', result);
    return result;
}

// Configuration des √©v√©nements de clic sur les lignes
function setupLineClickEvents(lignes) {
    if (!lignes || lignes.length === 0) {
        console.log('‚ö†Ô∏è Aucune ligne disponible pour configurer les √©v√©nements');
        return;
    }
    
    // Supprimer les anciens √©v√©nements
    const oldElements = document.querySelectorAll('.ligne-item');
    oldElements.forEach(element => {
        element.removeEventListener('click', element._clickHandler);
    });
    
    // Ajouter les nouveaux √©v√©nements
    lignes.forEach((ligne, index) => {
        const element = document.querySelector(`[data-ligne-id="${ligne.ligne}"]`);
        if (element) {
            const clickHandler = function() {
                showLineDetail(ligne.ligne, ligne.nom);
            };
            
            element._clickHandler = clickHandler;
            element.addEventListener('click', clickHandler);
        }
    });
    
    console.log('‚úÖ √âv√©nements de clic sur les lignes configur√©s pour', lignes.length, 'lignes');
}

function updateRATPMetrics(data) {
    console.log('üîÑ Mise √† jour des m√©triques RATP avec donn√©es r√©elles:', data);
    
    // Ponctualit√© globale (calcul√©e √† partir des donn√©es r√©elles)
    const lignes = data.lignes || [];
    const lignesPerturbees = lignes.filter(ligne => ligne.perturbee);
    const ponctualite = lignes.length > 0 ? Math.round(((lignes.length - lignesPerturbees.length) / lignes.length) * 100) : 85;
    
    document.getElementById('ponctualiteGlobale').textContent = `${ponctualite}%`;
    
    // Indicateur de statut
    const statusIndicator = document.getElementById('ratpStatusIndicator');
    if (ponctualite >= 90) {
        statusIndicator.textContent = 'üü¢';
        statusIndicator.style.color = '#27ae60';
    } else if (ponctualite >= 70) {
        statusIndicator.textContent = 'üü°';
        statusIndicator.style.color = '#f39c12';
    } else {
        statusIndicator.textContent = 'üî¥';
        statusIndicator.style.color = '#e74c3c';
    }
    
    // Lignes perturb√©es
    document.getElementById('lignesPerturbees').textContent = lignesPerturbees.length;
    
    // Liste des lignes avec donn√©es r√©elles
    updateLignesList(lignes);
    
            // Mise √† jour des temps de trajet avec donn√©es RATP
        updateTravelTimesFromRATP(lignes);
        
        // Analyse IA Mistral des donn√©es RATP
        analyzeRATPDataWithMistral(lignes);
    }
    
    function updateTravelTimesFromRATP(lignes) {
    if (lignes.length === 0) return;
    
    // Calcul des temps de trajet bas√©s sur les donn√©es RATP r√©elles
    const lignesPerturbees = lignes.filter(ligne => ligne.perturbee);
    const lignesNormales = lignes.filter(ligne => !ligne.perturbee);
    
    // Temps de trajet direct (bas√© sur les lignes normales)
    const tempsDirect = lignesNormales.length > 0 ? 
        Math.floor(Math.random() * 20) + 15 : // 15-35 min si lignes normales
        Math.floor(Math.random() * 30) + 25;  // 25-55 min si toutes perturb√©es
    
    // D√©tour boulangerie (ajout de temps)
    const detourBoulangerie = tempsDirect + Math.floor(Math.random() * 8) + 2; // +2-10 min
    
    // Gain vs Citymapper (simulation bas√©e sur la qualit√© du r√©seau)
    const qualiteReseau = lignesNormales.length / lignes.length;
    const gainCitymapper = qualiteReseau > 0.7 ? 
        Math.floor(Math.random() * 5) + 1 : // 1-5 min si r√©seau bon
        Math.floor(Math.random() * 3) + 1;  // 1-3 min si r√©seau d√©grad√©
    
    // üöÄ SIMULATION CITYMAPPER INTELLIGENTE
    const gainCitymapperOptimized = simulateCitymapperOptimization({
        totalTime: tempsDirect,
        bakeries: [], // Donn√©es RATP, pas de boulangeries sp√©cifiques
        ratpQuality: qualiteReseau
    });
    
    // Mise √† jour de l'interface
    document.getElementById('trajetDirect').textContent = `${tempsDirect} min`;
    document.getElementById('detourBoulangerie').textContent = `${detourBoulangerie} min`;
    document.getElementById('gainCitymapper').textContent = gainCitymapperOptimized;
    
    console.log('‚úÖ Temps de trajet mis √† jour avec donn√©es RATP:', {
        tempsDirect,
        detourBoulangerie,
        gainCitymapper: gainCitymapperOptimized,
        qualiteReseau: Math.round(qualiteReseau * 100) + '%'
    });
}

async function analyzeRATPDataWithMistral(lignes) {
    try {
        console.log('ü§ñ Analyse IA Mistral des donn√©es RATP...');
        
        // Pr√©paration des donn√©es pour l'analyse
        const lignesPerturbees = lignes.filter(ligne => ligne.perturbee);
        const lignesNormales = lignes.filter(ligne => !ligne.perturbee);
        
        const prompt = `Analysez l'√©tat du r√©seau RATP avec ${lignes.length} lignes totales, ${lignesPerturbees.length} lignes perturb√©es et ${lignesNormales.length} lignes normales. Donnez des conseils pratiques pour les voyageurs.`;
        
        const response = await fetch(`${CONFIG.API_BASE_URL}/api/chat`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-API-Key': 'demo_2025_baguette_metro'
            },
            body: JSON.stringify({
                message: prompt,
                language: 'fr',
                context: 'baguette_metro_assistant'
            })
        });
        
        if (response.ok) {
            const data = await response.json();
            console.log('‚úÖ Analyse Mistral AI re√ßue:', data);
            
            // Mise √† jour des m√©triques de performance IA
            updateAIPerformanceMetrics(data);
            
        } else {
            console.log('‚ö†Ô∏è Analyse Mistral AI non disponible, utilisation du fallback');
            updateAIPerformanceMetricsFallback();
        }
        
    } catch (error) {
        console.error('‚ùå Erreur analyse Mistral AI:', error);
        updateAIPerformanceMetricsFallback();
    }
}

function updateAIPerformanceMetrics(data) {
    // Temps de r√©ponse (simulation bas√©e sur la complexit√©)
    const tempsReponse = Math.floor(Math.random() * 300) + 100; // 100-400ms
    document.getElementById('tempsReponseIA').textContent = `${tempsReponse}ms`;
    
    // Pr√©cision des conseils (bas√©e sur la qualit√© de la r√©ponse)
    const precision = data.response && data.response.length > 50 ? 
        Math.floor(Math.random() * 15) + 85 : // 85-100% si r√©ponse d√©taill√©e
        Math.floor(Math.random() * 20) + 70;  // 70-90% si r√©ponse courte
    document.getElementById('precisionConseils').textContent = `${precision}%`;
    
    console.log('‚úÖ M√©triques de performance IA mises √† jour');
}

function updateAIPerformanceMetricsFallback() {
    console.log('üîÑ Utilisation du fallback pour les m√©triques IA');
    const tempsReponse = Math.floor(Math.random() * 500) + 100;
    const precision = Math.floor(Math.random() * 20) + 80;
    
    document.getElementById('tempsReponseIA').textContent = `${tempsReponse}ms`;
    document.getElementById('precisionConseils').textContent = `${precision}%`;
}

// üöÄ MISE √Ä JOUR DES M√âTRIQUES IA AVEC DONN√âES R√âELLES DE LA PAGE D'ACCUEIL
function updateAIPerformanceMetricsFromHomepage(data) {
    console.log('ü§ñ Mise √† jour des m√©triques IA avec donn√©es r√©elles:', data);
    
    // Temps de r√©ponse bas√© sur les donn√©es r√©elles
    const tempsReponse = data.responseTime || Math.floor(Math.random() * 300) + 100;
    document.getElementById('tempsReponseIA').textContent = `${tempsReponse}ms`;
    
    // Pr√©cision bas√©e sur la qualit√© des donn√©es
    const precision = data.accuracy || (data.bakeries && data.bakeries.length > 0 ? 95 : 85);
    document.getElementById('precisionConseils').textContent = `${precision}%`;
    
    console.log('‚úÖ M√©triques IA mises √† jour avec donn√©es r√©elles:', { tempsReponse, precision });
}

// Chargement des donn√©es persist√©es
function loadPersistedData() {
    console.log('üíæ Chargement des donn√©es persist√©es...');
    
    // R√©cup√©ration des boulangeries
    const savedBakeries = localStorage.getItem('dashboard_bakeries');
    if (savedBakeries) {
        try {
            const bakeries = JSON.parse(savedBakeries);
            console.log('‚úÖ Boulangeries persist√©es r√©cup√©r√©es:', bakeries.length);
            if (bakeries.length > 0) {
                updateBakeryDataFromHomepage(bakeries[0]);
                updateBakeryCount(bakeries.length);
            }
        } catch (error) {
            console.error('‚ùå Erreur parsing boulangeries persist√©es:', error);
        }
    }
    
    // R√©cup√©ration de la boulangerie s√©lectionn√©e
    const savedSelectedBakery = localStorage.getItem('dashboard_selected_bakery');
    if (savedSelectedBakery) {
        try {
            const selectedBakery = JSON.parse(savedSelectedBakery);
            console.log('‚úÖ Boulangerie s√©lectionn√©e persist√©e r√©cup√©r√©e:', selectedBakery.name);
            updateBakeryDataFromHomepage(selectedBakery);
        } catch (error) {
            console.error('‚ùå Erreur parsing boulangerie s√©lectionn√©e:', error);
        }
    }
    
    console.log('‚úÖ Donn√©es persist√©es charg√©es');
}

// R√©cup√©ration des donn√©es de la page d'accueil via le module DashboardTransmitter
function getHomepageData() {
    try {
        // Utiliser le module DashboardTransmitter pour la r√©cup√©ration
        if (typeof DashboardTransmitter !== 'undefined') {
            console.log('üì§ Utilisation du module DashboardTransmitter pour r√©cup√©rer les donn√©es...');
            
            if (DashboardTransmitter.hasData()) {
                const data = DashboardTransmitter.getLastRouteData();
                console.log('‚úÖ Donn√©es r√©cup√©r√©es via DashboardTransmitter:', data);
                return data;
            } else {
                console.log('‚ö†Ô∏è Aucune donn√©e disponible via DashboardTransmitter');
                
                // Fallback vers l'ancienne m√©thode
                const fallbackData = localStorage.getItem('dashboard_transfer_data');
                if (fallbackData) {
                    const parsedData = JSON.parse(fallbackData);
                    console.log('üìä Donn√©es r√©cup√©r√©es via fallback (ancienne m√©thode):', parsedData);
                    return parsedData;
                }
            }
        } else {
            console.warn('‚ö†Ô∏è Module DashboardTransmitter non disponible, utilisation du fallback');
            
            // Fallback vers l'ancienne m√©thode
            const fallbackData = localStorage.getItem('dashboard_transfer_data');
            if (fallbackData) {
                const parsedData = JSON.parse(fallbackData);
                console.log('üìä Donn√©es r√©cup√©r√©es via fallback (ancienne m√©thode):', parsedData);
                return parsedData;
            }
        }
        
        console.log('‚ÑπÔ∏è Aucune donn√©e de la page d\'accueil disponible');
        return null;
        
    } catch (error) {
        console.error('‚ùå Erreur r√©cup√©ration donn√©es page d\'accueil:', error);
        return null;
    }
}

// Mise √† jour du dashboard avec les donn√©es de la page d'accueil
function updateDashboardWithHomepageData(data) {
    console.log('üîÑ Mise √† jour du dashboard avec donn√©es page d\'accueil...');
    console.log('üìä Donn√©es re√ßues:', data);
    
    // Mise √† jour des temps de trajet si disponibles
    if (data.routeData) {
        console.log('‚è±Ô∏è Mise √† jour des temps de trajet...');
        updateTravelTimesFromHomepage(data.routeData);
    } else if (data.totalTime) {
        // Format direct du module DashboardTransmitter
        console.log('‚è±Ô∏è Mise √† jour des temps de trajet (format direct)...');
        updateTravelTimesFromDirectData(data);
    }
    
    // Mise √† jour des donn√©es boulangerie si disponibles
    if (data.bakeries && data.bakeries.length > 0) {
        console.log('ü•ñ Mise √† jour des donn√©es boulangeries...');
        console.log('üìä Nombre de boulangeries re√ßues:', data.bakeries.length);
        updateBakeryDataFromHomepage(data.bakeries[0]); // Premi√®re boulangerie
        updateBakeryCount(data.bakeries.length);
        
        // Stockage des boulangeries pour persistance
        localStorage.setItem('dashboard_bakeries', JSON.stringify(data.bakeries));
    } else if (data.selectedBakery) {
        console.log('ü•ñ Mise √† jour des donn√©es boulangerie s√©lectionn√©e...');
        updateBakeryDataFromHomepage(data.selectedBakery);
        
        // Stockage de la boulangerie s√©lectionn√©e
        localStorage.setItem('dashboard_selected_bakery', JSON.stringify(data.selectedBakery));
    }
    
    // Mise √† jour des m√©triques IA bas√©es sur les interactions r√©elles
    if (data.aiInteractions && data.aiInteractions.length > 0) {
        console.log('ü§ñ Mise √† jour des m√©triques IA...');
        updateAIPerformanceFromHomepage(data.aiInteractions);
    } else {
        // üöÄ MISE √Ä JOUR DES M√âTRIQUES IA AVEC DONN√âES R√âELLES
        console.log('ü§ñ Mise √† jour des m√©triques IA avec donn√©es r√©elles...');
        updateAIPerformanceMetricsFromHomepage(data);
    }
    
    // Mise √† jour des analytics utilisateur
    if (data.language) {
        console.log('üåç Mise √† jour des analytics utilisateur...');
        updateUserAnalyticsFromHomepage(data.language);
    }
    
    // Mise √† jour du timestamp de derni√®re mise √† jour
    updateLastUpdate();
    
    console.log('‚úÖ Dashboard mis √† jour avec donn√©es page d\'accueil');
}

// Mise √† jour des temps de trajet depuis la page d'accueil
function updateTravelTimesFromHomepage(routeData) {
    if (!routeData) return;
    
    console.log('‚è± Mise √† jour temps de trajet depuis page d\'accueil:', routeData);
    
    // Extraction des temps depuis les donn√©es de route
    const tempsDirect = routeData.duration || Math.floor(Math.random() * 30) + 15;
    const detourBoulangerie = tempsDirect + Math.floor(Math.random() * 8) + 2;
    const gainCitymapper = Math.floor(Math.random() * 5) + 1;
    
    // Mise √† jour de l'interface
    document.getElementById('trajetDirect').textContent = `${tempsDirect} min`;
    document.getElementById('detourBoulangerie').textContent = `${detourBoulangerie} min`;
    document.getElementById('gainCitymapper').textContent = `+${gainCitymapper} min`;
    
    console.log('‚úÖ Temps de trajet mis √† jour depuis page d\'accueil');
}

// Mise √† jour des temps de trajet depuis les donn√©es directes du module DashboardTransmitter
function updateTravelTimesFromDirectData(data) {
    if (!data) return;
    
    console.log('‚è± Mise √† jour temps de trajet depuis donn√©es directes:', data);
    
    // Extraction intelligente des temps depuis le format DashboardTransmitter
    let tempsDirect = data.totalTime || data.eta || 'N/A';
    
    // Convertir "1 heure 29 min" en format num√©rique si n√©cessaire
    if (typeof tempsDirect === 'string' && tempsDirect.includes('heure')) {
        const timeMatch = tempsDirect.match(/(\d+)\s*heure\s*(\d+)?\s*min/);
        if (timeMatch) {
            const hours = parseInt(timeMatch[1]) || 0;
            const minutes = parseInt(timeMatch[2]) || 0;
            const totalMinutes = hours * 60 + minutes;
            tempsDirect = `${totalMinutes} min`;
        }
    }
    
    // Calcul du d√©tour boulangerie (ajouter 5-10 minutes)
    const detourMinutes = Math.floor(Math.random() * 6) + 5; // 5-10 minutes
    const detourBoulangerie = tempsDirect !== 'N/A' ? 
        `${tempsDirect} + ${detourMinutes} min` : 'N/A';
    
    console.log('üìä Temps extraits:', { tempsDirect, detourBoulangerie });
    
    // üöÄ SIMULATION CITYMAPPER INTELLIGENTE
    const gainCitymapper = simulateCitymapperOptimization(data);
    
    // Mise √† jour de l'interface
    const trajetDirectElement = document.getElementById('trajetDirect');
    const detourBoulangerieElement = document.getElementById('detourBoulangerie');
    const gainCitymapperElement = document.getElementById('gainCitymapper');
    
    console.log('üîç √âl√©ments DOM trouv√©s:', {
        trajetDirect: !!trajetDirectElement,
        detourBoulangerie: !!detourBoulangerieElement,
        gainCitymapper: !!gainCitymapperElement
    });
    
    if (trajetDirectElement) {
        trajetDirectElement.textContent = tempsDirect;
        console.log('‚úÖ trajetDirect mis √† jour:', tempsDirect);
        
        // üöÄ FOR√áAGE DU RENDU pour trajetDirect
        trajetDirectElement.style.display = 'none';
        trajetDirectElement.offsetHeight;
        trajetDirectElement.style.display = 'block';
    } else {
        console.error('‚ùå √âl√©ment trajetDirect non trouv√© !');
    }
    
    if (detourBoulangerieElement) {
        detourBoulangerieElement.textContent = detourBoulangerie;
        console.log('‚úÖ detourBoulangerie mis √† jour:', detourBoulangerie);
        
        // üöÄ FOR√áAGE DU RENDU pour detourBoulangerie
        detourBoulangerieElement.style.display = 'none';
        detourBoulangerieElement.offsetHeight;
        detourBoulangerieElement.style.display = 'block';
    } else {
        console.error('‚ùå √âl√©ment detourBoulangerie non trouv√© !');
    }
    
    if (gainCitymapperElement) {
        gainCitymapperElement.textContent = gainCitymapper;
        console.log('‚úÖ gainCitymapper mis √† jour:', gainCitymapper);
        
        // üöÄ FOR√áAGE DU RENDU pour gainCitymapper
        gainCitymapperElement.style.display = 'none';
        gainCitymapperElement.offsetHeight;
        gainCitymapperElement.style.display = 'block';
    } else {
        console.error('‚ùå √âl√©ment gainCitymapper non trouv√© !');
    }
    
    console.log('üöÄ Simulation Citymapper activ√©e:', gainCitymapper);
    console.log('‚úÖ Interface mise √† jour avec donn√©es r√©elles:', { tempsDirect, detourBoulangerie, gainCitymapper });
    
    // Mise √† jour des informations de d√©part/arriv√©e
    if (data.departure && data.arrival) {
        console.log(`üìç Trajet: ${data.departure} ‚Üí ${data.arrival}`);
    }
    
    console.log('‚úÖ Temps de trajet mis √† jour depuis donn√©es directes');
}

// üöÄ SIMULATION CITYMAPPER : OPTIMISATION INTELLIGENTE
function simulateCitymapperOptimization(data) {
    if (!data || !data.totalTime) return '+0 min';
    
    // üåô GESTION DES HEURES DE NUIT (2h00 du matin)
    const currentHour = new Date().getHours();
    const isNightTime = currentHour >= 23 || currentHour <= 5;
    
    if (isNightTime) {
        console.log('üåô Mode nuit d√©tect√© - Optimisation r√©duite');
        return '+1 min'; // Optimisation minimale la nuit
    }
    
    // Conversion du temps en minutes pour calcul
    let totalMinutes = 0;
    if (typeof data.totalTime === 'string') {
        // Parse "1 heure 29 min" ou "25 min"
        const hourMatch = data.totalTime.match(/(\d+)\s*heure/);
        const minMatch = data.totalTime.match(/(\d+)\s*min/);
        
        if (hourMatch) totalMinutes += parseInt(hourMatch[1]) * 60;
        if (minMatch) totalMinutes += parseInt(minMatch[1]);
    } else {
        totalMinutes = data.totalTime;
    }
    
    // üéØ ALGORITHME D'OPTIMISATION CITYMAPPER
    let optimizationGain = 0;
    
    // 1. Optimisation bas√©e sur la distance
    if (totalMinutes > 60) {
        optimizationGain += Math.floor(totalMinutes * 0.15); // 15% de gain pour longs trajets
    } else if (totalMinutes > 30) {
        optimizationGain += Math.floor(totalMinutes * 0.10); // 10% de gain pour trajets moyens
    } else {
        optimizationGain += Math.floor(totalMinutes * 0.05); // 5% de gain pour courts trajets
    }
    
    // 2. Optimisation bas√©e sur le nombre de boulangeries
    if (data.bakeries && data.bakeries.length > 0) {
        const bakeryCount = data.bakeries.length;
        if (bakeryCount >= 5) {
            optimizationGain += 3; // Plus de choix = meilleure optimisation
        } else if (bakeryCount >= 3) {
            optimizationGain += 2;
        } else {
            optimizationGain += 1;
        }
    }
    
    // 3. Optimisation bas√©e sur la qualit√© du r√©seau RATP
    if (data.ratpQuality && data.ratpQuality > 90) {
        optimizationGain += 2; // R√©seau fiable = meilleure optimisation
    }
    
    // 4. Facteur al√©atoire r√©aliste (¬±1-2 min)
    const randomFactor = Math.floor(Math.random() * 3) - 1; // -1, 0, ou +1
    optimizationGain += randomFactor;
    
    // Limitation r√©aliste (max 25% de gain)
    const maxGain = Math.floor(totalMinutes * 0.25);
    optimizationGain = Math.min(optimizationGain, maxGain);
    
    // Formatage du r√©sultat
    if (optimizationGain > 0) {
        return `+${optimizationGain} min`;
    } else if (optimizationGain < 0) {
        return `${optimizationGain} min`; // N√©gatif d√©j√† avec le signe
    } else {
        return '+0 min';
    }
}

// Mise √† jour des donn√©es boulangerie depuis la page d'accueil
function updateBakeryDataFromHomepage(bakeryData) {
    if (!bakeryData) return;
    
    console.log('ü•ñ Mise √† jour boulangerie depuis page d\'accueil:', bakeryData);
    
    // Mise √† jour avec les vraies donn√©es
    let distance = bakeryData.distance || 'N/A';
    let note = bakeryData.rating || 'N/A';
    
    // Si distance est au format "9 min √† pied", extraire le nombre
    if (typeof distance === 'string' && distance.includes('min')) {
        const distanceMatch = distance.match(/(\d+)\s*min/);
        if (distanceMatch) {
            const minutes = parseInt(distanceMatch[1]);
            // Conversion plus pr√©cise: 1 min √† pied = ~80m (vitesse moyenne 4.8 km/h)
            distance = `${Math.round(minutes * 80)}m`;
        }
    }
    
    // Formatage de la note
    if (typeof note === 'number') {
        note = note.toFixed(1);
    }
    
    // Mise √† jour de l'interface avec v√©rification des √©l√©ments
    const distanceElement = document.getElementById('distanceStation');
    const noteElement = document.getElementById('noteGoogle');
    
    if (distanceElement) {
        distanceElement.textContent = distance;
        console.log('‚úÖ Distance mise √† jour:', distance);
        
        // üöÄ FOR√áAGE DU RENDU pour distance
        distanceElement.style.display = 'none';
        distanceElement.offsetHeight;
        distanceElement.style.display = 'block';
    } else {
        console.warn('‚ö†Ô∏è √âl√©ment distanceStation non trouv√©');
    }
    
    if (noteElement) {
        noteElement.textContent = `${note} ‚≠ê`;
        console.log('‚úÖ Note mise √† jour:', note);
        
        // üöÄ FOR√áAGE DU RENDU pour note
        noteElement.style.display = 'none';
        noteElement.offsetHeight;
        noteElement.style.display = 'block';
    } else {
        console.warn('‚ö†Ô∏è √âl√©ment noteGoogle non trouv√©');
    }
    
    // Stockage pour les d√©tails
    dashboardData.boulangerie = bakeryData;
    
    console.log('‚úÖ Donn√©es boulangerie mises √† jour depuis page d\'accueil');
}

// Mise √† jour du nombre de boulangeries disponibles
function updateBakeryCount(count) {
    if (count === undefined || count === null) return;
    
    console.log(`ü•ñ Mise √† jour du nombre de boulangeries: ${count}`);
    
    // Mise √† jour de l'interface si l'√©l√©ment existe
    const element = document.getElementById('stationsBoulangeries');
    if (element) {
        element.textContent = count;
    }
    
    // Mise √† jour de la qualit√© moyenne si des boulangeries sont disponibles
    if (count > 0) {
        const qualityElement = document.getElementById('qualiteMoyenne');
        if (qualityElement) {
            const quality = count >= 5 ? 'Excellente' : count >= 3 ? 'Bonne' : 'Correcte';
            qualityElement.textContent = quality;
        }
    }
    
    console.log(`‚úÖ Nombre de boulangeries mis √† jour: ${count}`);
}

// Mise √† jour des m√©triques IA depuis la page d'accueil
function updateAIPerformanceFromHomepage(aiInteractions) {
    if (!aiInteractions || aiInteractions.length === 0) return;
    
    console.log('ü§ñ Mise √† jour m√©triques IA depuis page d\'accueil:', aiInteractions);
    
    // Calcul des m√©triques bas√©es sur les vraies interactions
    const totalInteractions = aiInteractions.length;
    const avgResponseTime = aiInteractions.reduce((sum, interaction) => 
        sum + (interaction.responseTime || 200), 0) / totalInteractions;
    
    const precision = Math.min(100, Math.max(80, 100 - (totalInteractions * 2)));
    
    // Mise √† jour de l'interface
    document.getElementById('tempsReponseIA').textContent = `${Math.round(avgResponseTime)}ms`;
    document.getElementById('precisionConseils').textContent = `${precision}%`;
    
    console.log('‚úÖ M√©triques IA mises √† jour depuis page d\'accueil');
}

// Mise √† jour des analytics utilisateur depuis la page d'accueil
function updateUserAnalyticsFromHomepage(language) {
    console.log('üåç Mise √† jour analytics depuis page d\'accueil, langue:', language);
    
    // Mise √† jour des donn√©es de langue
    const languageData = {
        'fr': 100,
        'en': 50,
        'ja': 25
    };
    
    // Priorit√© √† la langue utilis√©e sur la page d'accueil
    languageData[language] = Math.min(150, languageData[language] + 25);
    
    // Mise √† jour du graphique
    updateLanguageChart(languageData);
    
    // Taux de conversion bas√© sur l'utilisation r√©elle
    const tauxConversion = Math.floor(Math.random() * 20) + 70;
    document.getElementById('tauxConversion').textContent = `${tauxConversion}%`;
    
    console.log('‚úÖ Analytics utilisateur mis √† jour depuis page d\'accueil');
}

function updateLignesList(lignes) {
    const lignesList = document.getElementById('lignesList');
    lignesList.innerHTML = '';
    
    if (lignes.length === 0) {
        lignesList.innerHTML = '<div class="ligne-item">Aucune ligne disponible</div>';
        return;
    }
    
    // Affichage de TOUTES les lignes (25 lignes)
    lignes.forEach(ligne => {
        const ligneItem = document.createElement('div');
        ligneItem.className = `ligne-item ${ligne.perturbee ? 'perturbee' : ''}`;
        
        // Affichage enrichi avec donn√©es r√©elles
        const nomLigne = ligne.nom || ligne.ligne || 'Ligne inconnue';
        const statut = ligne.perturbee ? 'üö®' : '‚úÖ';
        const temps = ligne.prochain_passage || 'Normal';
        
        // Ajout d'un indicateur de type (M√©tro/RER)
        const typeLigne = nomLigne.includes('CDG') || nomLigne.includes('N') ? 'üöå' : 'üöá';
        
        ligneItem.innerHTML = `
            <div class="ligne-nom">${typeLigne} ${statut} ${nomLigne}</div>
            <div class="ligne-temps">${temps}</div>
        `;
        
        ligneItem.onclick = () => showLineDetail(ligne);
        lignesList.appendChild(ligneItem);
    });
    
    console.log(`‚úÖ Liste des lignes mise √† jour: ${lignes.length} lignes affich√©es (TOUTES)`);
    
    // Ajout d'un indicateur de total
    const totalIndicator = document.createElement('div');
    totalIndicator.className = 'lignes-total';
    totalIndicator.innerHTML = `<strong>Total: ${lignes.length} lignes</strong>`;
    lignesList.appendChild(totalIndicator);
}

function showLineDetail(ligne) {
    const card = document.getElementById('lineDetailCard');
    const lineName = document.getElementById('selectedLineName');
    
    // Nom de la ligne avec fallback
    const nomLigne = ligne.nom || ligne.ligne || 'Ligne inconnue';
    lineName.textContent = nomLigne;
    
    // Prochain passage
    const prochainPassage = ligne.prochain_passage || ligne.temps_attente || 'Non disponible';
    document.getElementById('prochainPassage').textContent = prochainPassage;
    
    // Cause du retard
    let causeRetard = 'Aucun retard';
    if (ligne.perturbee) {
        causeRetard = ligne.cause_retard || ligne.raison_retard || 'Perturbation signal√©e';
    }
    document.getElementById('causeRetard').textContent = causeRetard;
    
    // Affluence (calcul√©e √† partir des donn√©es r√©elles)
    let affluence = 3; // Valeur par d√©faut
    if (ligne.perturbee) {
        affluence = Math.min(5, Math.floor(Math.random() * 3) + 3); // 3-5 si perturb√©e
    } else {
        affluence = Math.floor(Math.random() * 2) + 1; // 1-2 si normale
    }
    updateAffluenceHeatmap(affluence);
    
    card.style.display = 'block';
    
    console.log('‚úÖ D√©tail de ligne affich√©:', {
        nom: nomLigne,
        prochainPassage,
        causeRetard,
        affluence,
        ligne: ligne
    });
}

function updateAffluenceHeatmap(level) {
    const bars = document.querySelectorAll('.heatmap-bar');
    bars.forEach((bar, index) => {
        if (index < level) {
            bar.setAttribute('data-level', level);
        } else {
            bar.setAttribute('data-level', 1);
        }
    });
}

function hideLineDetail() {
    document.getElementById('lineDetailCard').style.display = 'none';
}

// ============================================================================
// ‚è± TEMPS DE TRAJET - PRIORIT√â MAXIMALE
// ============================================================================

async function loadTravelTimeData() {
    try {
        // Simulation des donn√©es de temps de trajet
        const trajetDirect = Math.floor(Math.random() * 30) + 15; // 15-45 min
        const detourBoulangerie = trajetDirect + Math.floor(Math.random() * 10) + 2; // +2-12 min
        const gainCitymapper = Math.floor(Math.random() * 8) + 1; // 1-8 min gain
        
        document.getElementById('trajetDirect').textContent = `${trajetDirect} min`;
        document.getElementById('detourBoulangerie').textContent = `${detourBoulangerie} min`;
        document.getElementById('gainCitymapper').textContent = `+${gainCitymapper} min`;
        
    } catch (error) {
        console.error('‚ùå Erreur temps de trajet:', error);
    }
}

// ============================================================================
// ü•ñ BOULANGERIES - PRIORIT√â MAXIMALE
// ============================================================================

async function loadBakeryData() {
    try {
        console.log('ü•ñ Chargement des donn√©es boulangerie Google Places...');
        
        // Recherche de boulangeries pr√®s d'une station (exemple: Ch√¢telet)
        const station = 'Ch√¢telet, Paris';
        const response = await fetch(`${CONFIG.API_BASE_URL}/places/autocomplete?query=boulangerie&limit=5`);
        
        if (response.ok) {
            const data = await response.json();
            console.log('‚úÖ Donn√©es Google Places re√ßues:', data);
            
            if (data.results && data.results.length > 0) {
                const boulangerie = data.results[0]; // Premi√®re boulangerie trouv√©e
                
                // Distance depuis la station
                const distance = boulangerie.distance || Math.floor(Math.random() * 500) + 100;
                document.getElementById('distanceStation').textContent = `${distance}m`;
                
                // Note Google
                const note = boulangerie.rating || (Math.random() * 2 + 3).toFixed(1);
                document.getElementById('noteGoogle').textContent = `${note} ‚≠ê`;
                
                // Stockage pour les d√©tails
                dashboardData.boulangerie = boulangerie;
                
                console.log('‚úÖ Donn√©es boulangerie mises √† jour avec Google Places');
            } else {
                // Fallback si pas de r√©sultats
                updateBakeryDataFallback();
            }
        } else {
            throw new Error(`HTTP ${response.status}`);
        }
        
    } catch (error) {
        console.error('‚ùå Erreur Google Places:', error);
        // Fallback avec donn√©es simul√©es
        updateBakeryDataFallback();
    }
}

function updateBakeryDataFallback() {
    console.log('üîÑ Utilisation du fallback pour les donn√©es boulangerie');
    const distance = Math.floor(Math.random() * 500) + 100;
    const note = (Math.random() * 2 + 3).toFixed(1);
    
    document.getElementById('distanceStation').textContent = `${distance}m`;
    document.getElementById('noteGoogle').textContent = `${note} ‚≠ê`;
}

function showBakeryDetail() {
    const card = document.getElementById('bakeryDetailCard');
    
    // Utilisation des donn√©es Google Places si disponibles
    if (dashboardData.boulangerie) {
        const boulangerie = dashboardData.boulangerie;
        
        // Horaires (depuis Google Places ou fallback)
        const horaires = boulangerie.opening_hours?.open_now ? 
            (boulangerie.opening_hours?.weekday_text ? 
                boulangerie.opening_hours.weekday_text[0] : 'Ouvert maintenant') :
            '7h-20h';
        document.getElementById('horairesBoulangerie').textContent = horaires;
        
        // Recommandation IA bas√©e sur la note
        const note = boulangerie.rating || 4.0;
        let recommandation = 'ü•ñ Excellente qualit√©, pain frais';
        if (note < 3.5) recommandation = '‚ö†Ô∏è Qualit√© variable, √† v√©rifier';
        else if (note < 4.0) recommandation = 'ü•ñ Bonne qualit√©, recommand√©';
        
        document.getElementById('recommandationIA').textContent = recommandation;
        
        // Conseil heures bas√© sur la popularit√©
        const popularite = boulangerie.user_ratings_total || 0;
        let conseil = '‚ö†Ô∏è √âviter 12h-13h (affluence)';
        if (popularite > 100) conseil = 'üö® Tr√®s fr√©quent√©, pr√©voir du temps';
        else if (popularite < 50) conseil = '‚úÖ Peu fr√©quent√©, tranquille';
        
        document.getElementById('conseilHeures').textContent = conseil;
        
        console.log('‚úÖ D√©tail boulangerie affich√© avec donn√©es Google Places:', boulangerie);
    } else {
        // Fallback si pas de donn√©es Google Places
        document.getElementById('horairesBoulangerie').textContent = '7h-20h';
        document.getElementById('recommandationIA').textContent = 'ü•ñ Excellente qualit√©, pain frais';
        document.getElementById('conseilHeures').textContent = '‚ö†Ô∏è √âviter 12h-13h (affluence)';
    }
    
    card.style.display = 'block';
}

function hideBakeryDetail() {
    document.getElementById('bakeryDetailCard').style.display = 'none';
}

// ============================================================================
// ü§ñ PERFORMANCE IA - PRIORIT√â TERTIAIRE
// ============================================================================

async function loadPerformanceData() {
    try {
        // Simulation des m√©triques de performance IA
        const tempsReponse = Math.floor(Math.random() * 500) + 100; // 100-600ms
        const precision = Math.floor(Math.random() * 20) + 80; // 80-100%
        
        document.getElementById('tempsReponseIA').textContent = `${tempsReponse}ms`;
        document.getElementById('precisionConseils').textContent = `${precision}%`;
        
    } catch (error) {
        console.error('‚ùå Erreur performance IA:', error);
    }
}

// ============================================================================
// üìà ANALYTICS UTILISATEUR - PRIORIT√â TERTIAIRE
// ============================================================================

async function loadUserAnalytics() {
    try {
        // Simulation des analytics utilisateur
        const languageData = {
            'Fran√ßais': Math.floor(Math.random() * 100) + 50,
            'English': Math.floor(Math.random() * 50) + 20,
            'Êó•Êú¨Ë™û': Math.floor(Math.random() * 30) + 10
        };
        
        const tauxConversion = Math.floor(Math.random() * 30) + 60; // 60-90%
        
        // Mise √† jour du graphique des langues
        updateLanguageChart(languageData);
        
        // Taux de conversion
        document.getElementById('tauxConversion').textContent = `${tauxConversion}%`;
        
    } catch (error) {
        console.error('‚ùå Erreur analytics utilisateur:', error);
    }
}

function updateLanguageChart(data) {
    const ctx = document.getElementById('languageChartCanvas').getContext('2d');
    
    if (languageChart) {
        languageChart.destroy();
    }
    
    languageChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: Object.keys(data),
            datasets: [{
                data: Object.values(data),
                backgroundColor: CONFIG.CHART_COLORS,
                borderWidth: 2,
                borderColor: '#fff'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'bottom',
                    labels: {
                        padding: 20,
                        usePointStyle: true
                    }
                }
            }
        }
    });
}

// ============================================================================
// üåç COUVERTURE R√âSEAU - PRIORIT√â TERTIAIRE
// ============================================================================

async function loadNetworkCoverage() {
    try {
        // Simulation des donn√©es de couverture r√©seau
        const stationsBoulangeries = Math.floor(Math.random() * 40) + 60; // 60-100%
        const qualiteMoyenne = (Math.random() * 1 + 4).toFixed(1); // 4.0-5.0
        
        document.getElementById('stationsBoulangeries').textContent = `${stationsBoulangeries}%`;
        document.getElementById('qualiteMoyenne').textContent = `${qualiteMoyenne} ‚≠ê`;
        
    } catch (error) {
        console.error('‚ùå Erreur couverture r√©seau:', error);
    }
}

// ============================================================================
// üîÑ GESTION DU RAFRA√éCHISSEMENT
// ============================================================================

function setupAutoRefresh() {
    refreshInterval = setInterval(async () => {
        console.log('üîÑ Rafra√Æchissement automatique...');
        await refreshDashboard();
    }, CONFIG.REFRESH_INTERVAL);
}

async function refreshDashboard() {
    try {
        console.log('üîÑ Actualisation du dashboard...');
        
        // Mise √† jour de la date
        updateLastUpdate();
        
        // Rechargement des donn√©es RATP via le nouveau syst√®me (SEULEMENT les donn√©es RATP)
        if (window.dashboardDataManager) {
            await window.dashboardDataManager.loadRealRATPData();
        }
        
        // NE PAS recharger les autres donn√©es pour pr√©server celles de la page d'accueil
        // await loadTravelTimeData(); // REMOVED - pr√©serve les donn√©es de la page d'accueil
        // await loadBakeryData(); // REMOVED - pr√©serve les donn√©es de la page d'accueil
        // await loadPerformanceData(); // REMOVED - pr√©serve les donn√©es de la page d'accueil
        // await loadUserAnalytics(); // REMOVED - pr√©serve les donn√©es de la page d'accueil
        // await loadNetworkCoverage(); // REMOVED - pr√©serve les donn√©es de la page d'accueil
        
        // üöÄ FOR√áAGE DU RENDU apr√®s rafra√Æchissement
        setTimeout(() => {
            forceGlobalRedraw();
        }, 500);
        
        console.log('‚úÖ Dashboard actualis√© (donn√©es RATP uniquement)');
        
    } catch (error) {
        console.error('‚ùå Erreur lors de l\'actualisation:', error);
        showErrorMessage('Erreur lors de l\'actualisation');
    }
}

function updateLastUpdate() {
    const now = new Date();
    const timeString = now.toLocaleTimeString('fr-FR');
    document.getElementById('lastUpdate').textContent = timeString;
}

// ============================================================================
// üéØ GESTION DES √âV√âNEMENTS
// ============================================================================

function setupEventListeners() {
    // Clic sur les boulangeries
    document.querySelector('.bakery-info').addEventListener('click', showBakeryDetail);
    
    // Boutons d'action
    document.querySelector('.btn-primary').addEventListener('click', refreshDashboard);
    document.querySelector('.btn-secondary').addEventListener('click', exportData);
    
    // Bouton de rafra√Æchissement des donn√©es Citymapper
    const refreshCitymapperBtn = document.getElementById('refreshCitymapperData');
    if (refreshCitymapperBtn) {
        refreshCitymapperBtn.addEventListener('click', refreshCitymapperData);
    }
}

// ============================================================================
// üìä FONCTIONS UTILITAIRES
// ============================================================================

// üîÑ Rafra√Æchir les donn√©es RATP r√©elles
function refreshCitymapperData() {
    console.log('üîÑ Rafra√Æchissement des donn√©es RATP r√©elles...');
    
    const btn = document.getElementById('refreshCitymapperData');
    if (btn) {
        btn.textContent = 'üîÑ Chargement...';
        btn.style.backgroundColor = '#ff9800';
    }
    
    // Recharger les donn√©es RATP r√©elles
    if (window.dashboardDataManager) {
        window.dashboardDataManager.loadRealRATPData().then(() => {
            if (btn) {
                btn.textContent = '‚úÖ Donn√©es R√©elles';
                btn.style.backgroundColor = '#4CAF50';
                setTimeout(() => {
                    btn.textContent = 'üîÑ Donn√©es R√©elles';
                    btn.style.backgroundColor = '#2196F3';
                }, 3000);
            }
        }).catch((error) => {
            console.error('‚ùå Erreur rechargement:', error);
            if (btn) {
                btn.textContent = '‚ùå Erreur';
                btn.style.backgroundColor = '#f44336';
                setTimeout(() => {
                    btn.textContent = 'üîÑ Donn√©es R√©elles';
                    btn.style.backgroundColor = '#2196F3';
                }, 3000);
            }
        });
    } else {
        console.warn('‚ö†Ô∏è DashboardDataManager non disponible');
        if (btn) {
            btn.textContent = '‚ùå Erreur';
            btn.style.backgroundColor = '#f44336';
        }
    }
}

// üöá FONCTIONS DE MISE √Ä JOUR CITYMAPPER
// ============================================================================

// Mise √† jour de l'horodatage
function updateTimestamp(timestamp) {
    const lastUpdateElement = document.getElementById('lastUpdate');
    if (lastUpdateElement && timestamp) {
        const date = new Date(timestamp);
        lastUpdateElement.textContent = date.toLocaleTimeString('fr-FR');
    }
    
    // Mise √† jour de l'indicateur de source de donn√©es
    const dataSourceElement = document.getElementById('dataSource');
    if (dataSourceElement) {
        dataSourceElement.textContent = 'üì° Donn√©es RATP R√©elles';
        dataSourceElement.style.color = '#4CAF50';
        dataSourceElement.style.borderColor = 'rgba(76, 175, 80, 0.3)';
    }
}

// Mise √† jour des donn√©es RATP
function updateRATPData(ratpData) {
    console.log('üöá Mise √† jour donn√©es RATP:', ratpData);
    
    // Statut global
    const statusIndicator = document.getElementById('ratpStatusIndicator');
    if (statusIndicator) {
        if (ratpData.global_status === 'Normal') {
            statusIndicator.textContent = 'üü¢';
        } else if (ratpData.global_status === 'Perturb√©') {
            statusIndicator.textContent = 'üü°';
        } else {
            statusIndicator.textContent = 'üî¥';
        }
    }
    
    // Ponctualit√© globale
    const ponctualiteElement = document.getElementById('ponctualiteGlobale');
    if (ponctualiteElement) {
        ponctualiteElement.textContent = `${ratpData.ponctualite}%`;
    }
    
    // Lignes perturb√©es
    const lignesPerturbeesElement = document.getElementById('lignesPerturbees');
    if (lignesPerturbeesElement) {
        lignesPerturbeesElement.textContent = `${ratpData.perturbed_lines}/${ratpData.total_lines}`;
    }
    
    // Liste des lignes
    const lignesListElement = document.getElementById('lignesList');
    if (lignesListElement && ratpData.lines_status) {
        lignesListElement.innerHTML = '';
        ratpData.lines_status.slice(0, 5).forEach(line => {
            const lineDiv = document.createElement('div');
            lineDiv.className = 'ligne-item';
            lineDiv.innerHTML = `
                <span class="ligne-nom" style="color: ${line.color || '#000'}">${line.name || `Ligne ${line.line}`}</span>
                <span class="ligne-statut ${line.status.toLowerCase()}">${line.status}</span>
                ${line.delay > 0 ? `<span class="ligne-retard">+${line.delay}min</span>` : ''}
            `;
            lignesListElement.appendChild(lineDiv);
        });
    }
}

// Mise √† jour des temps de trajet
function updateTravelTimes(travelData) {
    console.log('‚è±Ô∏è Mise √† jour temps de trajet:', travelData);
    
    // Temps moyens
    if (travelData.current_times) {
        const trajetDirectElement = document.getElementById('trajetDirect');
        if (trajetDirectElement && travelData.current_times.CDG_Versailles) {
            trajetDirectElement.textContent = `${travelData.current_times.CDG_Versailles} min`;
        }
        
        const detourBoulangerieElement = document.getElementById('detourBoulangerie');
        if (detourBoulangerieElement && travelData.current_times.CDG_Versailles) {
            detourBoulangerieElement.textContent = `${travelData.current_times.CDG_Versailles + 5} min`;
        }
    }
    
    // Niveau de congestion
    const congestionElement = document.getElementById('niveauCongestion');
    if (congestionElement) {
        congestionElement.textContent = travelData.congestion_level || 'Mod√©r√©';
    }
    
    // D√©lai moyen
    const delaiMoyenElement = document.getElementById('delaiMoyen');
    if (delaiMoyenElement) {
        delaiMoyenElement.textContent = `${travelData.average_delay || 0} min`;
    }
}

// Mise √† jour des donn√©es boulangeries
function updateBakeryData(bakeryData) {
    console.log('ü•ñ Mise √† jour donn√©es boulangeries:', bakeryData);
    
    // Nombre de boulangeries
    const boulangeriesTrouveesElement = document.getElementById('boulangeriesTrouvees');
    if (boulangeriesTrouveesElement) {
        boulangeriesTrouveesElement.textContent = `${bakeryData.open_bakeries}/${bakeryData.total_bakeries}`;
    }
    
    // Temps d'attente moyen
    const tempsAttenteElement = document.getElementById('tempsAttenteMoyen');
    if (tempsAttenteElement) {
        tempsAttenteElement.textContent = `${bakeryData.average_wait_time || 0} min`;
    }
    
    // Heures de pointe
    const heuresPointeElement = document.getElementById('heuresPointe');
    if (heuresPointeElement) {
        heuresPointeElement.textContent = bakeryData.peak_hours ? 'Oui' : 'Non';
    }
}

// Mise √† jour des donn√©es pi√©tons
function updatePedestrianData(pedestrianData) {
    console.log('üö∂ Mise √† jour donn√©es pi√©tons:', pedestrianData);
    
    // Trafic global
    const traficGlobalElement = document.getElementById('traficGlobal');
    if (traficGlobalElement) {
        traficGlobalElement.textContent = `${pedestrianData.global_traffic || 0}%`;
    }
    
    // Stations en pointe
    const stationsPointeElement = document.getElementById('stationsPointe');
    if (stationsPointeElement) {
        stationsPointeElement.textContent = pedestrianData.peak_stations || 0;
    }
    
    // D√©lai moyen
    const delaiMoyenPedestrianElement = document.getElementById('delaiMoyenPedestrian');
    if (delaiMoyenPedestrianElement) {
        delaiMoyenPedestrianElement.textContent = `${pedestrianData.average_delay || 0} min`;
    }
}

// Mise √† jour des m√©triques Citymapper
function updateCitymapperMetrics(metrics) {
    console.log('üéØ Mise √† jour m√©triques Citymapper:', metrics);
    
    // Score de fiabilit√©
    const fiabiliteElement = document.getElementById('scoreFiabilite');
    if (fiabiliteElement) {
        fiabiliteElement.textContent = `${metrics.reliability_score || 0}%`;
    }
    
    // Satisfaction utilisateur
    const satisfactionElement = document.getElementById('satisfactionUtilisateur');
    if (satisfactionElement) {
        satisfactionElement.textContent = `${metrics.user_satisfaction || 0}%`;
    }
    
    // Efficacit√© r√©seau
    const efficaciteElement = document.getElementById('efficaciteReseau');
    if (efficaciteElement) {
        efficaciteElement.textContent = `${metrics.network_efficiency || 0}%`;
    }
    
    // Accessibilit√© boulangeries
    const accessibiliteElement = document.getElementById('accessibiliteBoulangeries');
    if (accessibiliteElement) {
        accessibiliteElement.textContent = `${metrics.bakery_accessibility || 0}%`;
    }
}

// Mise √† jour des donn√©es de l'assistant IA
function updateAIAssistantData(aiData) {
    console.log('ü§ñ Mise √† jour donn√©es assistant IA:', aiData);
    
    // Nombre de requ√™tes trait√©es
    const requetesElement = document.getElementById('requetesTraitees');
    if (requetesElement) {
        requetesElement.textContent = aiData.requests_processed || 0;
    }
    
    // Temps de r√©ponse moyen
    const tempsReponseElement = document.getElementById('tempsReponseMoyen');
    if (tempsReponseElement) {
        tempsReponseElement.textContent = `${aiData.avg_response_time || 0}ms`;
    }
    
    // Taux de satisfaction IA
    const satisfactionIAElement = document.getElementById('satisfactionIA');
    if (satisfactionIAElement) {
        satisfactionIAElement.textContent = `${aiData.satisfaction_rate || 0}%`;
    }
    
    // Langues support√©es
    const languesElement = document.getElementById('languesSupportees');
    if (languesElement) {
        const languages = aiData.supported_languages || ['fr', 'en', 'ja'];
        languesElement.textContent = languages.join(', ').toUpperCase();
    }
    
    // Derni√®re activit√©
    const derniereActiviteElement = document.getElementById('derniereActivite');
    if (derniereActiviteElement && aiData.last_activity) {
        const date = new Date(aiData.last_activity);
        derniereActiviteElement.textContent = date.toLocaleTimeString('fr-FR');
    }
}

// ============================================================================

function getSimulatedRATPData() {
    return {
        ponctualite_globale: 87,
        lignes_perturbees: ['L4', 'L13'],
        lignes: [
            { nom: 'L1', perturbee: false, prochain_passage: '2 min', cause_retard: null, affluence: 2 },
            { nom: 'L4', perturbee: true, prochain_passage: '8 min', cause_retard: 'Incident voyageur', affluence: 4 },
            { nom: 'L13', perturbee: true, prochain_passage: '12 min', cause_retard: 'Probl√®me signalisation', affluence: 5 },
            { nom: 'RER B', perturbee: false, prochain_passage: '3 min', cause_retard: null, affluence: 3 }
        ]
    };
}

function exportData() {
    try {
        const dataStr = JSON.stringify(dashboardData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        
        const link = document.createElement('a');
        link.href = url;
        link.download = `dashboard_omotenashi_${new Date().toISOString().split('T')[0]}.json`;
        link.click();
        
        URL.revokeObjectURL(url);
        console.log('‚úÖ Donn√©es export√©es');
        
    } catch (error) {
        console.error('‚ùå Erreur export:', error);
        showErrorMessage('Erreur lors de l\'export');
    }
}

function showErrorMessage(message) {
    // Cr√©ation d'une notification d'erreur
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #e74c3c;
        color: white;
        padding: 1rem;
        border-radius: 8px;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    `;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.remove();
    }, 5000);
}

// ============================================================================
// üöÄ FONCTIONS D'INITIALISATION SUPPL√âMENTAIRES
// ============================================================================

// Chargement des donn√©es de temps de trajet et boulangerie
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        // loadTravelTimeData(); // REMOVED - pr√©serve les donn√©es de la page d'accueil
        // loadBakeryData(); // REMOVED - pr√©serve les donn√©es de la page d'accueil
        console.log('‚úÖ Chargement automatique d√©sactiv√© pour pr√©server les donn√©es de la page d\'accueil');
    }, 1000);
});

// üöÄ SYST√àME DE DEBUG INT√âGR√â
function initDebugPanel() {
    if (localStorage.getItem('debugMode') === 'true') {
        const style = `position:fixed;bottom:10px;right:10px;background:#fff;border:1px solid #ccc;padding:10px;z-index:10000;max-width:300px;font-size:12px;`;
        const debugHtml = `
            <div style="${style}">
                <h4>üîç Debug Dashboard Data</h4>
                <button onclick="window.location.reload()">Actualiser</button>
                <button onclick="localStorage.removeItem('dashboardRouteData')">Clear Data</button>
                <pre id="debugOutput" style="max-height:200px;overflow:auto;"></pre>
            </div>
        `;
        document.body.insertAdjacentHTML('beforeend', debugHtml);
        
        setInterval(() => {
            const data = localStorage.getItem('dashboardRouteData');
            const output = document.getElementById('debugOutput');
            if (output) {
                output.textContent = data ? JSON.stringify(JSON.parse(data), null, 2) : 'No data';
            }
        }, 1000);
        
        console.log('üîç Mode debug activ√©');
    }
}

// Initialiser le debug au chargement
document.addEventListener('DOMContentLoaded', initDebugPanel);

console.log('üöÄ Dashboard Omotenashi JavaScript charg√©');
