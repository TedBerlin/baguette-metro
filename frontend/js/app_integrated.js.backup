// Configuration de l'application avec int√©gration API r√©elle
const CONFIG = {
    API_BASE_URL: 'http://0.0.0.0:8000',
    DEFAULT_LAT: 48.8566,
    DEFAULT_LNG: 2.3522,
    DEFAULT_ZOOM: 13
};

// Configuration de l'auto-compl√©tion
const AUTOCOMPLETE_CONFIG = {
    MIN_QUERY_LENGTH: 3,
    DEBOUNCE_DELAY: 300,
    MAX_SUGGESTIONS: 5
};

// Variables globales
let map;
let currentLanguage = 'fr';
let markers = [];

// Traductions
const translations = {
    fr: {
        departure: 'D√©part',
        destination: 'Destination',
        calculate: 'Calculer l\'itin√©raire optimal',
        yourRoute: 'Votre trajet',
        results: 'R√©sultats',
        assistant: 'Assistant Conciergerie',
        askQuestion: 'Posez votre question...',
        loading: 'Chargement...',
        error: 'Erreur',
        noResults: 'Aucun r√©sultat trouv√©',
        apiError: 'Erreur de connexion √† l\'API'
    },
    en: {
        departure: 'Departure',
        destination: 'Destination',
        calculate: 'Calculate optimal route',
        yourRoute: 'Your route',
        results: 'Results',
        assistant: 'Concierge Assistant',
        askQuestion: 'Ask your question...',
        loading: 'Loading...',
        error: 'Error',
        noResults: 'No results found',
        apiError: 'API connection error'
    },
    ja: {
        departure: 'Âá∫Áô∫',
        destination: 'ÁõÆÁöÑÂú∞',
        calculate: 'ÊúÄÈÅ©„É´„Éº„Éà„ÇíË®àÁÆó',
        yourRoute: '„ÅÇ„Å™„Åü„ÅÆ„É´„Éº„Éà',
        results: 'ÁµêÊûú',
        assistant: '„Ç≥„É≥„Ç∑„Çß„É´„Ç∏„É•„Ç¢„Ç∑„Çπ„Çø„É≥„Éà',
        askQuestion: 'Ë≥™Âïè„Åó„Å¶„Åè„Å†„Åï„ÅÑ...',
        loading: 'Ë™≠„ÅøËæº„Åø‰∏≠...',
        error: '„Ç®„É©„Éº',
        noResults: 'ÁµêÊûú„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì',
        apiError: 'APIÊé•Á∂ö„Ç®„É©„Éº'
    }
};

// Initialisation de l'application
document.addEventListener('DOMContentLoaded', function() {
    initializeMap();
    setupEventListeners();
    setupLanguageSelector();
    addWelcomeMessage();
    testAPIConnection();
});

// Test de connexion aux APIs
async function testAPIConnection() {
    try {
        const response = await fetch(`${CONFIG.API_BASE_URL}/health`);
        if (response.ok) {
            console.log('‚úÖ API FastAPI connect√©e');
            addChatMessage('assistant', '‚úÖ Connexion aux APIs √©tablie. Toutes les fonctionnalit√©s sont op√©rationnelles !');
        } else {
            throw new Error('API non accessible');
        }
    } catch (error) {
        console.error('‚ùå Erreur API:', error);
        addChatMessage('assistant', '‚ö†Ô∏è APIs non accessibles. Mode d√©mo activ√© avec donn√©es simul√©es.');
    }
}

// Configuration de l'auto-compl√©tion
function setupAutocomplete(inputId, suggestionsId) {
    const input = document.getElementById(inputId);
    const suggestionsContainer = document.getElementById(suggestionsId);
    
    if (!input || !suggestionsContainer) {
        console.warn(`Auto-compl√©tion non configur√©e pour ${inputId}`);
        return;
    }
    
    let debounceTimer;
    
    input.addEventListener('input', function() {
        clearTimeout(debounceTimer);
        const query = this.value.trim();
        
        if (query.length < AUTOCOMPLETE_CONFIG.MIN_QUERY_LENGTH) {
            hideSuggestions(suggestionsContainer);
            return;
        }
        
        debounceTimer = setTimeout(() => {
            searchAddresses(query, suggestionsContainer, input);
        }, AUTOCOMPLETE_CONFIG.DEBOUNCE_DELAY);
    });
    
    // Masquer les suggestions en cliquant ailleurs
    document.addEventListener('click', function(e) {
        if (!input.contains(e.target) && !suggestionsContainer.contains(e.target)) {
            hideSuggestions(suggestionsContainer);
        }
    });
}

// Recherche d'adresses avec service hybride intelligent
async function searchAddresses(query, suggestionsContainer, input) {
    try {
        // Utiliser notre service hybride intelligent
        const response = await fetch(
            `${CONFIG.API_BASE_URL}/places/autocomplete?query=${encodeURIComponent(query)}&limit=${AUTOCOMPLETE_CONFIG.MAX_SUGGESTIONS}`
        );
        
        if (!response.ok) {
            throw new Error('Erreur de recherche d\'adresses');
        }
        
        const data = await response.json();
        
        if (data.predictions && data.predictions.length > 0) {
            showSuggestions(data.predictions, suggestionsContainer, input);
        } else {
            // Fallback vers OpenStreetMap direct si pas de r√©sultats
            console.log('üîÑ Fallback vers OpenStreetMap direct');
            const fallbackResponse = await fetch(
                `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=${AUTOCOMPLETE_CONFIG.MAX_SUGGESTIONS}&countrycodes=fr&accept-language=fr,en`
            );
            
            if (fallbackResponse.ok) {
                const fallbackData = await fallbackResponse.json();
                showSuggestions(fallbackData, suggestionsContainer, input);
            } else {
                showSuggestions([], suggestionsContainer, input);
            }
        }
        
    } catch (error) {
        console.error('Erreur recherche adresses:', error);
        showSuggestions([], suggestionsContainer, input);
    }
}

// Affichage des suggestions
function showSuggestions(suggestions, container, input) {
    container.innerHTML = '';
    
    if (suggestions.length === 0) {
        container.innerHTML = '<div class="suggestion-item no-results">Aucune suggestion trouv√©e</div>';
        container.style.display = 'block';
        return;
    }
    
    suggestions.forEach(suggestion => {
        const item = document.createElement('div');
        item.className = 'suggestion-item';
        item.textContent = suggestion.display_name;
        
        item.addEventListener('click', () => {
            selectSuggestion(suggestion, input, container);
        });
        
        container.appendChild(item);
    });
    
    container.style.display = 'block';
}

// S√©lection d'une suggestion
function selectSuggestion(suggestion, input, container) {
    input.value = suggestion.display_name;
    hideSuggestions(container);
    
    // Mettre √† jour la carte avec la position
    const lat = parseFloat(suggestion.lat);
    const lon = parseFloat(suggestion.lon);
    
    if (!isNaN(lat) && !isNaN(lon)) {
        // Ajouter un marqueur sur la carte
        const markerType = input.id === 'start-input' ? 'üöÄ' : 'üéØ';
        addMarker(lat, lon, suggestion.display_name, markerType, input.id);
        
        // Centrer la carte sur la position
        map.setView([lat, lon], 15);
        
        console.log(`Position s√©lectionn√©e: ${suggestion.display_name} (${lat}, ${lon})`);
    }
}

// Masquer les suggestions
function hideSuggestions(container) {
    container.style.display = 'none';
}

// Initialisation de la carte Leaflet
function initializeMap() {
    map = L.map('map').setView([CONFIG.DEFAULT_LAT, CONFIG.DEFAULT_LNG], CONFIG.DEFAULT_ZOOM);
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '¬© OpenStreetMap contributors'
    }).addTo(map);
    
    // Ajouter un marqueur par d√©faut (Paris)
    addMarker(CONFIG.DEFAULT_LAT, CONFIG.DEFAULT_LNG, 'Paris', 'üèõÔ∏è');
}

// Configuration des √©couteurs d'√©v√©nements
function setupEventListeners() {
    // Bouton de calcul d'itin√©raire
    document.getElementById('calculate-btn').addEventListener('click', calculateRoute);
    
    // Bouton d'envoi de message
    document.getElementById('send-btn').addEventListener('click', sendMessage);
    
    // Auto-compl√©tion pour les champs de saisie
    setupAutocomplete('start-input', 'start-suggestions');
    setupAutocomplete('end-input', 'end-suggestions');
    
    // √âcouteurs pour les champs de saisie (mise √† jour en temps r√©el)
    document.getElementById('start-input').addEventListener('input', updateJourneyDisplay);
    document.getElementById('end-input').addEventListener('input', updateJourneyDisplay);
    
    // Entr√©e dans le champ de message
    document.getElementById('message-input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            sendMessage();
        }
    });

    // Auto-compl√©tion Google Places
    setupGooglePlacesAutocomplete();
}

// Configuration de l'auto-compl√©tion Google Places
function setupGooglePlacesAutocomplete() {
    const startInput = document.getElementById('start-input');
    const endInput = document.getElementById('end-input');
    
    // Auto-compl√©tion avec l'API Google Places
    startInput.addEventListener('input', function() {
        if (this.value.length > 2) {
            showAutocompleteSuggestions(this, this.value);
        }
    });
    
    endInput.addEventListener('input', function() {
        if (this.value.length > 2) {
            showAutocompleteSuggestions(this, this.value);
        }
    });
}

// Affichage des suggestions d'auto-compl√©tion avec API r√©elle
async function showAutocompleteSuggestions(input, query) {
    try {
        // Appel √† l'API backend
        const response = await fetch(`${CONFIG.API_BASE_URL}/places/autocomplete?query=${encodeURIComponent(query)}`);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        const data = await response.json();
        
        if (data.error) {
            throw new Error(data.error);
        }
        
        // Utiliser les vraies suggestions de l'API
        const suggestions = data.predictions || [];
        
        // Cr√©er la liste de suggestions
        let suggestionList = input.parentNode.querySelector('.suggestions');
        if (!suggestionList) {
            suggestionList = document.createElement('ul');
            suggestionList.className = 'suggestions';
            input.parentNode.appendChild(suggestionList);
        }
        
        if (suggestions.length === 0) {
            suggestionList.innerHTML = '<li class="no-results">Aucune suggestion trouv√©e</li>';
            return;
        }
        
        suggestionList.innerHTML = suggestions.map(suggestion => 
            `<li onclick="selectSuggestion('${input.id}', '${suggestion.description}', ${suggestion.lat}, ${suggestion.lon})">
                <span class="suggestion-text">${suggestion.description}</span>
                <span class="suggestion-source">Google Places</span>
            </li>`
        ).join('');
        
    } catch (error) {
        console.error('Erreur auto-compl√©tion:', error);
        // Afficher un message d'erreur au lieu du fallback simul√©
        let suggestionList = input.parentNode.querySelector('.suggestions');
        if (!suggestionList) {
            suggestionList = document.createElement('ul');
            suggestionList.className = 'suggestions';
            input.parentNode.appendChild(suggestionList);
        }
        
        suggestionList.innerHTML = '<li class="error">Erreur de connexion √† l\'API Google Places</li>';
    }
}

// S√©lection d'une suggestion avec g√©ocodage
async function selectSuggestion(inputId, value, lat = null, lon = null) {
    document.getElementById(inputId).value = value;
    document.querySelectorAll('.suggestions').forEach(list => list.remove());
    
    // Si on a des coordonn√©es, mettre √† jour la carte
    if (lat && lon) {
        // Supprimer les anciens marqueurs
        markers.forEach(marker => map.removeLayer(marker));
        markers = [];
        
        // Ajouter le nouveau marqueur
        const marker = L.marker([lat, lon]).addTo(map);
        markers.push(marker);
        
        // Centrer la carte sur le marqueur
        map.setView([lat, lon], 15);
        
        // Ajouter un popup avec l'adresse
        marker.bindPopup(value).openPopup();
    }
}

// Configuration du s√©lecteur de langue
function setupLanguageSelector() {
    const langButtons = document.querySelectorAll('.lang-btn');
    
    langButtons.forEach(btn => {
        btn.addEventListener('click', function() {
            const lang = this.dataset.lang;
            changeLanguage(lang);
            
            // Mettre √† jour l'√©tat actif
            langButtons.forEach(b => b.classList.remove('active'));
            this.classList.add('active');
        });
    });
}

// Changement de langue
function changeLanguage(lang) {
    currentLanguage = lang;
    updateUIText();
}

// Mise √† jour du texte de l'interface
function updateUIText() {
    const t = translations[currentLanguage];
    
    // Mettre √† jour les labels
    document.querySelector('label[for="start-input"]').textContent = t.departure;
    document.querySelector('label[for="end-input"]').textContent = t.destination;
    document.getElementById('calculate-btn').textContent = t.calculate;
    document.querySelector('.map-section h2').textContent = t.yourRoute;
    document.querySelector('.results-section h2').textContent = t.results;
    document.querySelector('.assistant-section h2').textContent = t.assistant;
    document.getElementById('message-input').placeholder = t.askQuestion;
}

// Calcul d'itin√©raire avec API r√©elle
async function calculateRoute() {
    const start = document.getElementById('start-input').value.trim();
    const end = document.getElementById('end-input').value.trim();
    
    if (!start || !end) {
        showError('Veuillez remplir les champs de d√©part et d\'arriv√©e');
        return;
    }
    
    showLoading('Calcul de l\'itin√©raire en cours...');
    
    try {
        console.log('üîÑ D√©but du calcul d\'itin√©raire...');
        const routeData = await callRealRouteAPI(start, end);
        
        if (routeData) {
            console.log('‚úÖ Donn√©es ETA re√ßues:', routeData);
            console.log('ü•ñ Boulangeries trouv√©es:', routeData.bakeries);
            
            displayRealResults(routeData);
            addRouteMarkers(start, end, routeData);
            
            // CORRECTION: S'assurer que addBakeryMarkers est appel√©e
            if (routeData.bakeries && routeData.bakeries.length > 0) {
                console.log('üó∫Ô∏è Ajout des marqueurs de boulangeries...');
                addBakeryMarkers(routeData.bakeries);
            } else {
                console.log('‚ö†Ô∏è Aucune boulangerie trouv√©e dans les donn√©es');
            }
        } else {
            console.log('‚ö†Ô∏è API non accessible, utilisation du mode simulation');
            await simulateRouteCalculation(start, end);
            addRouteMarkers(start, end);
            displayResults(start, end);
        }
    } catch (error) {
        console.error('‚ùå Erreur calcul itin√©raire:', error);
        showError('Erreur lors du calcul de l\'itin√©raire');
    }
}

// Appel √† l'API r√©elle de calcul d'itin√©raire
async function callRealRouteAPI(start, end) {
    try {
        const response = await fetch(`${CONFIG.API_BASE_URL}/eta/calculate`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
                start_address: start, 
                end_address: end, 
                language: currentLanguage 
            })
        });
        
        if (response.ok) {
            const data = await response.json();
            console.log('‚úÖ Donn√©es ETA re√ßues:', data);
            return data;
        } else {
            console.log('‚ùå Erreur API ETA:', response.status);
            return null;
        }
    } catch (error) {
        console.log('‚ùå Erreur connexion API ETA:', error);
        return null;
    }
}

// Affichage des r√©sultats r√©els de l'API
function displayRealResults(routeData) {
    const container = document.getElementById('results-container');
    
    // Traduction des labels selon la langue
    const labels = getLabelsForLanguage(currentLanguage);
    
    container.innerHTML = `
        <div class="result-item">
            <h3>üöÄ ${labels.itineraryCalculated}</h3>
            <p><strong>${labels.departure}:</strong> ${routeData.start_address || 'N/A'}</p>
            <p><strong>${labels.arrival}:</strong> ${routeData.end_address || 'N/A'}</p>
            <p><strong>${labels.estimatedDuration}:</strong> ${routeData.eta || 'N/A'}</p>
            <p><strong>${labels.distance}:</strong> ${routeData.distance || 'N/A'}</p>
        </div>
        <div class="result-item">
            <h3>ü•ñ ${labels.bakeriesOnRoute}</h3>
            ${routeData.bakeries && routeData.bakeries.length > 0 ? 
                routeData.bakeries.map(b => `<p>‚Ä¢ ${b.name} (${b.distance}) ‚≠ê ${b.rating}</p>`).join('') : 
                `<p>‚Ä¢ ${labels.searchingBakeries}</p>`
            }
        </div>
        <div class="result-item">
            <h3>üöá ${labels.publicTransport}</h3>
            ${routeData.transport && routeData.transport.length > 0 ? 
                routeData.transport.map(t => `<p>‚Ä¢ ${t.line}: ${t.wait_time} ${labels.wait} (${t.duration})</p>`).join('') : 
                `<p>‚Ä¢ ${labels.metroLine1}: 3 ${labels.minWait}</p>`
            }
        </div>
    `;
}

// Ajouter les marqueurs de boulangeries sur la carte
function addBakeryMarkers(bakeries) {
    if (!bakeries || !map) {
        console.log('‚ùå addBakeryMarkers: bakeries ou map manquant');
        return;
    }
    
    console.log(`üó∫Ô∏è Ajout de ${bakeries.length} marqueurs de boulangeries`);
    
    // Supprimer les anciens marqueurs de boulangeries
    if (window.bakeryMarkers) {
        window.bakeryMarkers.forEach(marker => map.removeLayer(marker));
    }
    
    window.bakeryMarkers = [];
    
    bakeries.forEach((bakery, index) => {
        // Position simul√©e (√† remplacer par de vraies coordonn√©es)
        const lat = CONFIG.DEFAULT_LAT + (Math.random() - 0.5) * 0.01;
        const lng = CONFIG.DEFAULT_LNG + (Math.random() - 0.5) * 0.01;
        
        const bakeryIcon = L.divIcon({
            className: 'bakery-marker',
            html: 'ü•ñ',
            iconSize: [30, 30]
        });
        
        const marker = L.marker([lat, lng], { icon: bakeryIcon })
            .addTo(map)
            .bindPopup(`
                <div class="bakery-popup">
                    <h4>${bakery.name}</h4>
                    <p>üìç ${bakery.distance}</p>
                    <p>‚≠ê ${bakery.rating}/5</p>
                    <button onclick="showBakeryRoute(${lat}, ${lng})">${getLabelsForLanguage(currentLanguage).showRoute}</button>
                </div>
            `);
        
        window.bakeryMarkers.push(marker);
        console.log(`‚úÖ Marqueur boulangerie ajout√©: ${bakery.name} √† [${lat}, ${lng}]`);
    });
    
    console.log(`