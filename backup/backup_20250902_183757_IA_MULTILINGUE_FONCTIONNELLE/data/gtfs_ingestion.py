#!/usr/bin/env python3
"""
Module d'ingestion GTFS-RT avec stockage Parquet
"""

import os
import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
import pandas as pd
import pyarrow as pa
import pyarrow.parquet as pq
from pathlib import Path
import json

from .gtfs_realtime import RATPGTFSClient

logger = logging.getLogger(__name__)


class GTFSIngestionManager:
    """Gestionnaire d'ingestion des donn√©es GTFS-RT"""
    
    def __init__(self, data_dir: str = "data/processed"):
        self.data_dir = Path(data_dir)
        self.data_dir.mkdir(parents=True, exist_ok=True)
        
        # Sous-dossiers par type de donn√©es
        self.metro_dir = self.data_dir / "metro"
        self.rer_dir = self.data_dir / "rer"
        self.bus_dir = self.data_dir / "bus"
        self.tram_dir = self.data_dir / "tram"
        
        for dir_path in [self.metro_dir, self.rer_dir, self.bus_dir, self.tram_dir]:
            dir_path.mkdir(exist_ok=True)
        
        self.gtfs_client = RATPGTFSClient()
        
    async def ingest_realtime_data(self, route_type: str = "metros") -> Dict[str, Any]:
        """
        Ing√®re les donn√©es temps r√©el et les stocke en Parquet
        
        Args:
            route_type: Type de transport ('metros', 'rers', 'tramways', 'bus')
            
        Returns:
            Dict avec m√©tadonn√©es de l'ingestion
        """
        try:
            logger.info(f"üöá Ingestion des donn√©es {route_type}...")
            
            # R√©cup√©ration des donn√©es temps r√©el
            async with self.gtfs_client as client:
                realtime_data = await client.get_realtime_data(route_type)
            
            if not realtime_data:
                logger.warning(f"Aucune donn√©e r√©cup√©r√©e pour {route_type}")
                return self._get_ingestion_metadata(route_type, success=False)
            
            # Conversion en DataFrame
            df = self._convert_to_dataframe(realtime_data, route_type)
            
            # Stockage en Parquet
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"{route_type}_{timestamp}.parquet"
            
            if route_type == "metros":
                filepath = self.metro_dir / filename
            elif route_type == "rers":
                filepath = self.rer_dir / filename
            elif route_type == "tramways":
                filepath = self.tram_dir / filename
            else:
                filepath = self.bus_dir / filename
            
            # Sauvegarde Parquet avec compression
            df.to_parquet(filepath, compression='snappy', index=False)
            
            # M√©tadonn√©es
            metadata = self._get_ingestion_metadata(route_type, success=True, filepath=filepath, df=df)
            
            logger.info(f"‚úÖ Donn√©es {route_type} ing√©r√©es: {len(df)} enregistrements")
            return metadata
            
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de l'ingestion {route_type}: {e}")
            return self._get_ingestion_metadata(route_type, success=False, error=str(e))
    
    def _convert_to_dataframe(self, data: Dict[str, Any], route_type: str) -> pd.DataFrame:
        """Convertit les donn√©es GTFS-RT en DataFrame"""
        records = []
        timestamp = datetime.now()
        
        # Extraction des donn√©es selon le type de transport
        if route_type == "metros":
            records = self._extract_metro_data(data, timestamp)
        elif route_type == "rers":
            records = self._extract_rer_data(data, timestamp)
        elif route_type == "tramways":
            records = self._extract_tram_data(data, timestamp)
        else:
            records = self._extract_bus_data(data, timestamp)
        
        return pd.DataFrame(records)
    
    def _extract_metro_data(self, data: Dict[str, Any], timestamp: datetime) -> List[Dict]:
        """Extrait les donn√©es m√©tro"""
        records = []
        
        try:
            # Gestion du cas o√π data est une liste (donn√©es mock)
            if isinstance(data, list):
                for item in data:
                    if isinstance(item, dict):
                        record = {
                            'timestamp': timestamp,
                            'line_code': item.get('line_code', ''),
                            'direction': item.get('direction', ''),
                            'destination': item.get('destination', ''),
                            'message': item.get('message', ''),
                            'type': 'metro'
                        }
                        
                        # Ajout des horaires
                        schedules = item.get('schedules', [])
                        for i, time_info in enumerate(schedules[:5]):  # Max 5 horaires
                            if isinstance(time_info, dict):
                                record[f'eta_{i+1}'] = time_info.get('time', '')
                            else:
                                record[f'eta_{i+1}'] = str(time_info)
                        
                        records.append(record)
            else:
                # Structure des donn√©es m√©tro RATP (dictionnaire)
                for line_code, line_data in data.items():
                    if isinstance(line_data, dict) and 'schedules' in line_data:
                        for direction, schedules in line_data['schedules'].items():
                            for schedule in schedules:
                                record = {
                                    'timestamp': timestamp,
                                    'line_code': line_code,
                                    'direction': direction,
                                    'destination': schedule.get('destination', ''),
                                    'message': schedule.get('message', ''),
                                    'type': 'metro'
                                }
                                
                                # Ajout des horaires
                                if 'schedules' in schedule:
                                    for i, time_info in enumerate(schedule['schedules']):
                                        record[f'eta_{i+1}'] = time_info.get('time', '')
                                
                                records.append(record)
        except Exception as e:
            logger.error(f"Erreur extraction m√©tro: {e}")
        
        return records
    
    def _extract_rer_data(self, data: Dict[str, Any], timestamp: datetime) -> List[Dict]:
        """Extrait les donn√©es RER"""
        records = []
        
        try:
            # Gestion du cas o√π data est une liste (donn√©es mock)
            if isinstance(data, list):
                for item in data:
                    if isinstance(item, dict):
                        record = {
                            'timestamp': timestamp,
                            'line_code': item.get('line_code', ''),
                            'direction': item.get('direction', ''),
                            'destination': item.get('destination', ''),
                            'message': item.get('message', ''),
                            'type': 'rer'
                        }
                        
                        # Ajout des horaires
                        schedules = item.get('schedules', [])
                        for i, time_info in enumerate(schedules[:5]):  # Max 5 horaires
                            if isinstance(time_info, dict):
                                record[f'eta_{i+1}'] = time_info.get('time', '')
                            else:
                                record[f'eta_{i+1}'] = str(time_info)
                        
                        records.append(record)
            else:
                # Structure des donn√©es RER RATP (dictionnaire)
                for line_code, line_data in data.items():
                    if isinstance(line_data, dict) and 'schedules' in line_data:
                        for direction, schedules in line_data['schedules'].items():
                            for schedule in schedules:
                                record = {
                                    'timestamp': timestamp,
                                    'line_code': line_code,
                                    'direction': direction,
                                    'destination': schedule.get('destination', ''),
                                    'message': schedule.get('message', ''),
                                    'type': 'rer'
                                }
                                
                                if 'schedules' in schedule:
                                    for i, time_info in enumerate(schedule['schedules']):
                                        record[f'eta_{i+1}'] = time_info.get('time', '')
                                
                                records.append(record)
        except Exception as e:
            logger.error(f"Erreur extraction RER: {e}")
        
        return records
    
    def _extract_tram_data(self, data: Dict[str, Any], timestamp: datetime) -> List[Dict]:
        """Extrait les donn√©es tramway"""
        records = []
        
        try:
            # Gestion du cas o√π data est une liste (donn√©es mock)
            if isinstance(data, list):
                for item in data:
                    if isinstance(item, dict):
                        record = {
                            'timestamp': timestamp,
                            'line_code': item.get('line_code', ''),
                            'direction': item.get('direction', ''),
                            'destination': item.get('destination', ''),
                            'message': item.get('message', ''),
                            'type': 'tram'
                        }
                        
                        # Ajout des horaires
                        schedules = item.get('schedules', [])
                        for i, time_info in enumerate(schedules[:5]):  # Max 5 horaires
                            if isinstance(time_info, dict):
                                record[f'eta_{i+1}'] = time_info.get('time', '')
                            else:
                                record[f'eta_{i+1}'] = str(time_info)
                        
                        records.append(record)
            else:
                # Structure des donn√©es tram RATP (dictionnaire)
                for line_code, line_data in data.items():
                    if isinstance(line_data, dict) and 'schedules' in line_data:
                        for direction, schedules in line_data['schedules'].items():
                            for schedule in schedules:
                                record = {
                                    'timestamp': timestamp,
                                    'line_code': line_code,
                                    'direction': direction,
                                    'destination': schedule.get('destination', ''),
                                    'message': schedule.get('message', ''),
                                    'type': 'tram'
                                }
                                
                                if 'schedules' in schedule:
                                    for i, time_info in enumerate(schedule['schedules']):
                                        record[f'eta_{i+1}'] = time_info.get('time', '')
                                
                                records.append(record)
        except Exception as e:
            logger.error(f"Erreur extraction tram: {e}")
        
        return records
    
    def _extract_bus_data(self, data: Dict[str, Any], timestamp: datetime) -> List[Dict]:
        """Extrait les donn√©es bus"""
        records = []
        
        try:
            # Gestion du cas o√π data est une liste (donn√©es mock)
            if isinstance(data, list):
                for item in data:
                    if isinstance(item, dict):
                        record = {
                            'timestamp': timestamp,
                            'line_code': item.get('line_code', ''),
                            'direction': item.get('direction', ''),
                            'destination': item.get('destination', ''),
                            'message': item.get('message', ''),
                            'type': 'bus'
                        }
                        
                        # Ajout des horaires
                        schedules = item.get('schedules', [])
                        for i, time_info in enumerate(schedules[:5]):  # Max 5 horaires
                            if isinstance(time_info, dict):
                                record[f'eta_{i+1}'] = time_info.get('time', '')
                            else:
                                record[f'eta_{i+1}'] = str(time_info)
                        
                        records.append(record)
            else:
                # Structure des donn√©es bus RATP (dictionnaire)
                for line_code, line_data in data.items():
                    if isinstance(line_data, dict) and 'schedules' in line_data:
                        for direction, schedules in line_data['schedules'].items():
                            for schedule in schedules:
                                record = {
                                    'timestamp': timestamp,
                                    'line_code': line_code,
                                    'direction': direction,
                                    'destination': schedule.get('destination', ''),
                                    'message': schedule.get('message', ''),
                                    'type': 'bus'
                                }
                                
                                if 'schedules' in schedule:
                                    for i, time_info in enumerate(schedule['schedules']):
                                        record[f'eta_{i+1}'] = time_info.get('time', '')
                                
                                records.append(record)
        except Exception as e:
            logger.error(f"Erreur extraction bus: {e}")
        
        return records
    
    def _get_ingestion_metadata(self, route_type: str, success: bool, 
                               filepath: Optional[Path] = None, 
                               df: Optional[pd.DataFrame] = None,
                               error: Optional[str] = None) -> Dict[str, Any]:
        """G√©n√®re les m√©tadonn√©es d'ingestion"""
        metadata = {
            'route_type': route_type,
            'timestamp': datetime.now().isoformat(),
            'success': success,
            'filepath': str(filepath) if filepath else None,
            'record_count': len(df) if df is not None else 0,
            'error': error
        }
        
        # Sauvegarde des m√©tadonn√©es
        metadata_file = self.data_dir / f"ingestion_metadata_{route_type}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(metadata_file, 'w') as f:
            json.dump(metadata, f, indent=2, default=str)
        
        return metadata
    
    async def ingest_all_transport_types(self) -> Dict[str, Any]:
        """Ing√®re tous les types de transport"""
        transport_types = ['metros', 'rers', 'tramways', 'bus']
        results = {}
        
        for transport_type in transport_types:
            results[transport_type] = await self.ingest_realtime_data(transport_type)
            await asyncio.sleep(1)  # Pause entre les requ√™tes
        
        return results
    
    def get_latest_data(self, route_type: str, limit: int = 100) -> pd.DataFrame:
        """R√©cup√®re les derni√®res donn√©es ing√©r√©es"""
        if route_type == "metros":
            data_dir = self.metro_dir
        elif route_type == "rers":
            data_dir = self.rer_dir
        elif route_type == "tramways":
            data_dir = self.tram_dir
        else:
            data_dir = self.bus_dir
        
        # Liste des fichiers Parquet
        parquet_files = list(data_dir.glob("*.parquet"))
        if not parquet_files:
            return pd.DataFrame()
        
        # Tri par date de modification
        parquet_files.sort(key=lambda x: x.stat().st_mtime, reverse=True)
        
        # Lecture du fichier le plus r√©cent
        latest_file = parquet_files[0]
        df = pd.read_parquet(latest_file)
        
        return df.head(limit)
    
    def get_data_summary(self) -> Dict[str, Any]:
        """G√©n√®re un r√©sum√© des donn√©es ing√©r√©es"""
        summary = {
            'total_files': 0,
            'total_records': 0,
            'transport_types': {},
            'last_ingestion': None
        }
        
        for transport_type, data_dir in [
            ('metros', self.metro_dir),
            ('rers', self.rer_dir),
            ('tramways', self.tram_dir),
            ('bus', self.bus_dir)
        ]:
            parquet_files = list(data_dir.glob("*.parquet"))
            if parquet_files:
                # Fichier le plus r√©cent
                latest_file = max(parquet_files, key=lambda x: x.stat().st_mtime)
                df = pd.read_parquet(latest_file)
                
                summary['transport_types'][transport_type] = {
                    'file_count': len(parquet_files),
                    'latest_records': len(df),
                    'latest_file': latest_file.name,
                    'latest_timestamp': datetime.fromtimestamp(latest_file.stat().st_mtime).isoformat()
                }
                
                summary['total_files'] += len(parquet_files)
                summary['total_records'] += len(df)
                
                # Mise √† jour de la derni√®re ingestion
                file_time = datetime.fromtimestamp(latest_file.stat().st_mtime)
                if summary['last_ingestion'] is None or file_time > datetime.fromisoformat(summary['last_ingestion']):
                    summary['last_ingestion'] = file_time.isoformat()
        
        return summary


# Instance globale
ingestion_manager = GTFSIngestionManager()


async def run_ingestion_pipeline():
    """Pipeline d'ingestion complet"""
    logger.info("üöÄ D√©marrage du pipeline d'ingestion GTFS-RT")
    
    try:
        # Ingestion de tous les types de transport
        results = await ingestion_manager.ingest_all_transport_types()
        
        # R√©sum√©
        summary = ingestion_manager.get_data_summary()
        
        logger.info("‚úÖ Pipeline d'ingestion termin√©")
        logger.info(f"üìä R√©sum√©: {summary['total_files']} fichiers, {summary['total_records']} enregistrements")
        
        return results, summary
        
    except Exception as e:
        logger.error(f"‚ùå Erreur pipeline d'ingestion: {e}")
        return None, None


if __name__ == "__main__":
    # Test du pipeline
    asyncio.run(run_ingestion_pipeline())

